<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Lab UI — Policies</title>
  <link rel="stylesheet" href="/public/style.css" />
</head>
<body>
  <nav>
    <a href="/strategies">Strategies</a>
    <a href="/runs">Runs</a>
    <a href="/leaderboard">Leaderboard</a>
    <a href="/truth">Truth</a>
    <a href="/policies" class="active">Policies</a>
  </nav>

  <main>
    <h1>Policy Optimization</h1>
    <p class="hint">
      Run policy optimization on a path-only run to find the best exit policy for each caller.
      Uses grid search with explicit constraint-based scoring.
    </p>

    <section class="card">
      <h2>
        <span>Available Options & Commands</span>
        <button id="toggleHelp" style="float: right; font-size: 0.8em;">Show Help</button>
      </h2>
      <div id="helpSection" style="display: none;">
        <h3>Policy Types</h3>
        <div style="margin-left: 20px;">
          <h4>1. Fixed Stop (<code>fixed_stop</code>)</h4>
          <pre><code>{
  "kind": "fixed_stop",
  "stopPct": 0.20,        // Stop loss % (0.20 = 20% loss)
  "takeProfitPct": 1.0    // Optional: Take profit % (1.0 = 100% gain)
}</code></pre>

          <h4>2. Time Stop (<code>time_stop</code>)</h4>
          <pre><code>{
  "kind": "time_stop",
  "maxHoldMs": 3600000,   // Max hold time in milliseconds (1 hour)
  "takeProfitPct": 1.0    // Optional: Take profit %
}</code></pre>

          <h4>3. Trailing Stop (<code>trailing_stop</code>)</h4>
          <pre><code>{
  "kind": "trailing_stop",
  "activationPct": 0.20,  // Activate after 20% gain
  "trailPct": 0.10,       // Exit if drops 10% from peak
  "hardStopPct": 0.15     // Optional: Hard stop at 15% loss
}</code></pre>

          <h4>4. Ladder (<code>ladder</code>)</h4>
          <pre><code>{
  "kind": "ladder",
  "levels": [
    { "multiple": 2.0, "fraction": 0.5 },  // Exit 50% at 2x
    { "multiple": 3.0, "fraction": 0.3 },  // Exit 30% at 3x
    { "multiple": 5.0, "fraction": 0.2 }   // Exit 20% at 5x
  ],
  "stopPct": 0.20         // Optional: Stop loss for remaining position
}</code></pre>

          <h4>5. Combo (<code>combo</code>)</h4>
          <pre><code>{
  "kind": "combo",
  "policies": [
    { "kind": "fixed_stop", "stopPct": 0.15 },
    { "kind": "time_stop", "maxHoldMs": 7200000 }
  ]
}</code></pre>
        </div>

        <h3>Optimizer Constraints</h3>
        <div style="margin-left: 20px;">
          <pre><code>{
  "maxStopOutRate": 0.25,           // Max stop-out rate (0.25 = 25%)
  "maxP95DrawdownBps": -2000,       // Max 95th percentile drawdown in bps (-2000 = -20%)
  "maxTimeExposedMs": 3600000       // Max median time exposed in ms (1 hour)
}</code></pre>
        </div>

        <h3>CLI Command Options</h3>
        <div style="margin-left: 20px;">
          <h4>Optimize Command:</h4>
          <pre><code>quantbot backtest optimize \
  --caller "TY/ACC" \                    # Optional: caller name (optimizes all if omitted)
  --caller-groups '["caller1","caller2"]' \  # Optional: JSON array of callers
  --interval "5m" \                     # Required: Candle interval (1m, 5m, 15m, 1h)
  --from "2024-01-01T00:00:00Z" \      # Required: Start date (ISO 8601)
  --to "2024-01-31T23:59:59Z" \        # Required: End date (ISO 8601)
  --max-stop-out-rate 0.3 \            # Optional: Max stop-out rate (default: 0.3)
  --max-p95-drawdown-bps -3000 \       # Optional: Max p95 drawdown bps (default: -3000)
  --max-time-exposed-ms 172800000 \    # Optional: Max time exposed ms (default: 48h)
  --taker-fee-bps 30 \                 # Optional: Taker fee bps (default: 30)
  --slippage-bps 10 \                  # Optional: Slippage bps (default: 10)
  --execution-model simple \           # Optional: pumpfun, pumpswap, raydium, minimal, simple (default: simple)
  --format table                        # Optional: json, table, csv (default: table)</code></pre>

          <h4>Policy Command:</h4>
          <pre><code>quantbot backtest policy \
  --policy-json '{"kind":"fixed_stop","stopPct":0.20}' \  # Required: Policy JSON
  --policy-id "my-policy-id" \         # Optional: Policy ID (auto-generated if not provided)
  --filter "TY/ACC" \                  # Optional: Filter by caller name
  --interval "5m" \                    # Required: Candle interval
  --from "2024-01-01T00:00:00Z" \     # Required: Start date
  --to "2024-01-31T23:59:59Z" \       # Required: End date
  --taker-fee-bps 30 \                # Optional: Taker fee bps (default: 30)
  --slippage-bps 10 \                 # Optional: Slippage bps (default: 10)
  --execution-model simple \          # Optional: Execution model (default: simple)
  --run-id "existing-run-id" \        # Optional: Existing run ID to use
  --format json                        # Optional: json, table, csv (default: json)</code></pre>
        </div>

        <h3>Execution Models</h3>
        <div style="margin-left: 20px;">
          <ul>
            <li><code>simple</code> - Use simple --slippage-bps and --taker-fee-bps values (default)</li>
            <li><code>pumpfun</code> - PumpFun-specific slippage/latency model</li>
            <li><code>pumpswap</code> - PumpSwap-specific model</li>
            <li><code>raydium</code> - Raydium DEX model</li>
            <li><code>minimal</code> - Zero slippage/latency (for testing)</li>
          </ul>
        </div>

        <h3>Scoring Function</h3>
        <div style="margin-left: 20px;">
          <p><strong>Primary:</strong> Maximize median net return</p>
          <p><strong>Subject to:</strong></p>
          <ul>
            <li>Stop-out rate ≤ maxStopOutRate</li>
            <li>p95 drawdown ≤ maxP95DrawdownBps</li>
            <li>Median time-exposed ≤ maxTimeExposedMs</li>
          </ul>
          <p><strong>Tie-breakers:</strong></p>
          <ul>
            <li>Better tail capture</li>
            <li>Faster time-to-2x</li>
            <li>Lower median drawdown</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>Run Policy Backtest</h2>
      <div class="row">
        <label>Path-Only Run ID&nbsp;<input id="pathOnlyRunId" placeholder="run_id from path-only" /></label>
        <label>Caller&nbsp;<input id="callerPolicy" placeholder="caller name" /></label>
      </div>
      <div class="row">
        <label>Policy Type&nbsp;<select id="policyType">
          <option value="fixed-stop">Fixed Stop</option>
          <option value="time-stop">Time Stop</option>
          <option value="trailing-stop">Trailing Stop</option>
          <option value="ladder">Ladder</option>
        </select></label>
        <label>Policy JSON&nbsp;<textarea id="policyJson" rows="4" cols="50">{
  "type": "fixed-stop",
  "stopLossBps": -500,
  "takeProfitBps": 10000
}</textarea></label>
      </div>
      <div class="row">
        <button id="runPolicy">Run Policy Backtest</button>
        <span id="policyMsg"></span>
      </div>
    </section>

    <section class="card">
      <h2>Run Optimizer</h2>
      <div class="row">
        <label>Path-Only Run ID&nbsp;<input id="optRunId" placeholder="run_id from path-only" /></label>
        <label>Caller&nbsp;<input id="optCaller" placeholder="caller name" /></label>
        <label>Policy Type&nbsp;<select id="optPolicyType">
          <option value="fixed-stop">Fixed Stop</option>
          <option value="time-stop">Time Stop</option>
          <option value="trailing-stop">Trailing Stop</option>
        </select></label>
      </div>
      <div class="row">
        <label>Constraints&nbsp;<textarea id="constraintsJson" rows="3" cols="50">{
  "maxStopOutRate": 0.25,
  "maxP95DrawdownBps": 2000,
  "maxTimeExposedMs": 3600000
}</textarea></label>
      </div>
      <div class="row">
        <button id="runOptimize">Run Optimizer</button>
        <span id="optMsg"></span>
      </div>
    </section>

    <section class="card">
      <h2>Best Policies by Caller</h2>
      <div class="row">
        <label>Caller&nbsp;<input id="lookupCaller" placeholder="caller name" /></label>
        <button id="lookupPolicies">Lookup</button>
        <span id="lookupMsg"></span>
      </div>
      <div class="table-scroll">
        <table id="policiesTable">
          <thead>
            <tr>
              <th>Policy ID</th>
              <th>Score</th>
              <th>Policy JSON</th>
              <th>Constraints</th>
              <th>Created</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    // Toggle help section
    $("toggleHelp").onclick = () => {
      const helpSection = $("helpSection");
      const isVisible = helpSection.style.display !== "none";
      helpSection.style.display = isVisible ? "none" : "block";
      $("toggleHelp").textContent = isVisible ? "Show Help" : "Hide Help";
    };

    // Run policy backtest
    $("runPolicy").onclick = async () => {
      const path_only_run_id = $("pathOnlyRunId").value.trim();
      const caller_filter = $("callerPolicy").value.trim();
      const policy_json = $("policyJson").value.trim();

      if (!path_only_run_id) {
        $("policyMsg").textContent = "path_only_run_id required";
        return;
      }
      if (!policy_json) {
        $("policyMsg").textContent = "policy_json required";
        return;
      }

      try {
        const res = await fetch("/api/runs/policy", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ path_only_run_id, policy_json, caller_filter })
        });
        const data = await res.json();
        if (data.error) {
          $("policyMsg").textContent = "Error: " + data.error;
        } else {
          $("policyMsg").textContent = "Created policy run: " + data.run_id;
        }
      } catch (e) {
        $("policyMsg").textContent = "Error: " + e.message;
      }
    };

    // Run optimizer
    $("runOptimize").onclick = async () => {
      const path_only_run_id = $("optRunId").value.trim();
      const caller = $("optCaller").value.trim();
      const policy_type = $("optPolicyType").value;
      const constraints_json = $("constraintsJson").value.trim();

      if (!path_only_run_id) {
        $("optMsg").textContent = "path_only_run_id required";
        return;
      }
      if (!caller) {
        $("optMsg").textContent = "caller required";
        return;
      }

      try {
        const res = await fetch("/api/runs/optimize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ path_only_run_id, caller, policy_type, constraints_json })
        });
        const data = await res.json();
        if (data.error) {
          $("optMsg").textContent = "Error: " + data.error;
        } else {
          $("optMsg").textContent = "Created optimize run: " + data.run_id;
        }
      } catch (e) {
        $("optMsg").textContent = "Error: " + e.message;
      }
    };

    // Lookup best policies
    $("lookupPolicies").onclick = async () => {
      const caller = $("lookupCaller").value.trim();
      if (!caller) {
        $("lookupMsg").textContent = "enter caller name";
        return;
      }

      try {
        const res = await fetch("/api/policies/" + encodeURIComponent(caller));
        const rows = await res.json();

        const tbody = $("policiesTable").querySelector("tbody");
        tbody.innerHTML = "";

        if (!rows.length) {
          $("lookupMsg").textContent = "no policies found";
          return;
        }

        for (const r of rows) {
          const tr = document.createElement("tr");
          tr.innerHTML = [
            r.policy_id,
            r.score?.toFixed(4) ?? "–",
            `<code>${escapeHtml(r.policy_json?.slice(0, 80) ?? "")}</code>`,
            `<code>${escapeHtml(r.constraints_json?.slice(0, 60) ?? "")}</code>`,
            r.created_at
          ].map(v => `<td>${v}</td>`).join("");
          tbody.appendChild(tr);
        }

        $("lookupMsg").textContent = rows.length + " policies";
      } catch (e) {
        $("lookupMsg").textContent = "Error: " + e.message;
      }
    };

    function escapeHtml(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  </script>
</body>
</html>

