# QuantBot Candle Fetching Requirements

## Overview
This document defines the requirements for fetching OHLCV candles and token metadata in the QuantBot system.

## Critical Rules

### Mint Address Handling - ABSOLUTE REQUIREMENTS

⚠️ **NEVER MODIFY MINT ADDRESSES IN ANY WAY** ⚠️

#### Rule 1: NEVER Concatenate Mint Addresses
- ❌ FORBIDDEN: `mint.substring(0, 8) + '...'` - DO NOT use truncated mint in function calls
- ❌ FORBIDDEN: `${mint.slice(0, 10)}...${mint.slice(-10)}` - DO NOT create shortened versions for storage
- ❌ FORBIDDEN: Any string concatenation/manipulation that changes the mint value
- ✅ ALLOWED: `mint.substring(0, 20)` for **display/logging ONLY** - BUT always pass full mint to functions
- ✅ REQUIRED: Store and pass complete 32-44 character addresses

**Example - CORRECT:**
```typescript
logger.info('Processing token', { mint: mint.substring(0, 20) + '...' }); // Display only
await processToken(mint); // Full mint passed to function
```

**Example - WRONG:**
```typescript
const shortMint = mint.substring(0, 20);
await processToken(shortMint); // BREAKS EVERYTHING!
```

#### Rule 2: NEVER Change Mint Address Case
- ❌ FORBIDDEN: `mint.toLowerCase()` when storing to database
- ❌ FORBIDDEN: `mint.toUpperCase()` when storing to database
- ❌ FORBIDDEN: Any case transformation before API calls
- ❌ FORBIDDEN: Storing lowercased version instead of original
- ✅ ALLOWED: `mint.toLowerCase()` for **comparison/deduplication ONLY** - NEVER for storage
- ✅ REQUIRED: Preserve exact case as received from source (Telegram, API, etc.)

**Why:** Solana addresses are Base58-encoded and case-sensitive. Changing case = different address = API failures.

**Example - CORRECT:**
```typescript
// Compare using lowercase for deduplication
const isDuplicate = existingMints.some(m => m.toLowerCase() === mint.toLowerCase());
if (!isDuplicate) {
  await saveMint(mint); // Save ORIGINAL case
}
```

**Example - WRONG:**
```typescript
await saveMint(mint.toLowerCase()); // WRONG! Changes the address!
```

#### Rule 3: NEVER Split or Join Mint Addresses
- ❌ FORBIDDEN: `mint.split('').join('')`
- ❌ FORBIDDEN: Breaking mint into parts and reassembling
- ❌ FORBIDDEN: Any array/string operations that modify the mint
- ✅ REQUIRED: Keep mint as single, unmodified string throughout entire codebase

#### Rule 4: NEVER Truncate for Storage
- ❌ FORBIDDEN: Storing first 20 characters in database
- ❌ FORBIDDEN: VARCHAR(20) or any length < 44 characters
- ❌ FORBIDDEN: Removing characters to save database space
- ✅ REQUIRED: Use TEXT or VARCHAR(64) minimum
- ✅ REQUIRED: Store complete 32-44 character address
- ✅ ALLOWED: Truncate ONLY for display in UI/logs (not for storage/API calls)

**Database Schema - CORRECT:**
```sql
CREATE TABLE tokens (
  mint_address TEXT NOT NULL,  -- Full address, case-preserved
  symbol TEXT,
  timestamp DATETIME NOT NULL
);
```

**Database Schema - WRONG:**
```sql
CREATE TABLE tokens (
  mint_address VARCHAR(20),  -- TOO SHORT! WILL BREAK!
);
```

#### Why These Rules Matter

1. **Solana addresses are case-sensitive Base58 strings (32-44 chars)**
   - Changing case = different address = API failures = lost tokens
   - Truncating = invalid address = transaction failures

2. **API calls require exact, full addresses**
   - Birdeye API: Needs full mint for metadata/candles
   - Solana RPC: Needs exact address for account lookups
   - ClickHouse: Queries must match exact case
   - Any modification = 404 errors or wrong data

3. **Database integrity depends on exact matching**
   - Case changes break lookups and CREATE duplicates
   - Truncation makes addresses unusable for API calls
   - Original case must be preserved for all operations

#### Mint Address Handling Checklist

Before committing ANY code that touches mint addresses:

- [ ] No `.toLowerCase()` or `.toUpperCase()` before storage/API calls
- [ ] No `.substring()`, `.slice()`, or truncation before storage/API calls  
- [ ] No string concatenation that modifies the mint value
- [ ] Database fields are TEXT or VARCHAR(64+) to hold full address
- [ ] Logging truncates for display but functions receive full mint
- [ ] Deduplication compares lowercased but stores ORIGINAL case
- [ ] All API calls receive complete, unmodified mint addresses
- [ ] Mint addresses extracted from messages preserve original case

## Candle Fetching Strategy

### 1m Candles
- **Historical Requirement**: Fetch at least 52 periods (52 minutes) before alert time for Ichimoku calculations
- **Total Fetch**: Up to 5000 candles maximum per API call (Birdeye limit)
- **Start Point**: Alert time minus 52 minutes
- **End Point**: Extend forward from start point to fill up to 5000 candles total
- **Purpose**: High granularity data around alert time for precise entry pricing

### 5m Candles
- **Historical Requirement**: Fetch at least 52 periods (260 minutes = 4.33 hours) before alert time for Ichimoku calculations
- **Total Fetch**: Up to 5000 candles maximum per API call (Birdeye limit)
- **Start Point**: Alert time minus 52 periods (260 minutes)
- **End Point**: Extend forward from start point to fill up to 5000 candles total
- **Optimization Rule**: 
  - If the time range is more recent than 17 days, fetch additional historical data beyond 5000 candles
  - Reason: Same API cost for 1000 candles as 5000 candles, so maximize data retrieval
  - Use chunking: Make multiple API calls in 5000-candle chunks until reaching reasonable historical limit
- **Purpose**: Standard granularity for full transaction history and Ichimoku calculations

### Chunking Strategy
- All API calls are automatically chunked into 5000-candle windows
- `fetchBirdeyeCandles` handles chunking automatically
- Multiple API calls are made sequentially with small delays (100ms) between chunks to avoid rate limits
- Chunks are deduplicated and sorted by timestamp

## Token Metadata Enrichment

### Required Fields
- **Name**: Token name
- **Ticker/Symbol**: Token symbol
- **Market Cap (mcap)**: Current market capitalization

### Optional Fields (if available)
- **Socials**: Social media links (Twitter, Telegram, Discord, etc.)
- **Creator**: Token creator address/name
- **Top Wallet Holdings**: Percentage held by top wallets
- **Price**: Current token price
- **Decimals**: Token decimals
- **Logo URI**: Token logo URL
- **Volume 24h**: 24-hour trading volume
- **Price Change 24h**: 24-hour price change percentage

### Metadata Fetching
- Fetch from Birdeye API endpoint: `/defi/v3/token/meta-data/single`
- Fallback to token overview endpoint if metadata endpoint fails
- Cache metadata to avoid redundant API calls
- Non-blocking: Metadata fetching should not block candle fetching

## ClickHouse Optimization

### Pre-Fetch Check
- **Always check ClickHouse first** before making API calls
- Query ClickHouse for existing candles in the requested time range
- If ClickHouse has sufficient data, use it instead of API calls
- ClickHouse acts as a cache layer to reduce API quota usage

### Update Strategy
- **Default Rule**: Only update candles in ClickHouse if existing data is older than 24 hours
- **Exception**: Active calls (tokens being actively monitored)
  - Active calls should be updated via WebSocket streams in real-time
  - No need to fetch via API if WebSocket is providing live updates
  - WebSocket updates are more efficient and provide real-time data

### ClickHouse Storage
- Store candles with appropriate intervals (1m, 5m, 15m, 1h)
- Store full historical data (with 52-period lookback) for Ichimoku calculations
- Store metadata separately or alongside candles
- Use time-based partitioning for efficient queries

## Implementation Guidelines

### Function: `fetchHybridCandles`
- Check ClickHouse first
- If ClickHouse data is fresh (< 24hrs old) and not an active call, use ClickHouse
- Otherwise, fetch from API with:
  - 52-period lookback for Ichimoku
  - Up to 5000 candles per timeframe (1m and 5m)
  - Multiple chunks if needed for 5m candles (when > 17 days)
- Save fetched candles to ClickHouse
- Fetch and log metadata (non-blocking)

### Function: `fetchHybridCandlesWithMetadata`
- Same as `fetchHybridCandles` but also returns metadata synchronously
- Use when metadata is required immediately

### Metadata Function: `fetchTokenMetadata`
- Check cache first
- Fetch from Birdeye API
- Return enriched metadata with all available fields
- Handle errors gracefully (return null if unavailable)

## Error Handling

### API Failures
- Retry with exponential backoff for transient errors
- Return empty array if token not found (404)
- Log warnings for rate limits (429)
- Continue processing other tokens on individual failures

### ClickHouse Failures
- Fall back to API if ClickHouse query fails
- Log warnings but don't block candle fetching
- Continue with API fetch if ClickHouse is unavailable

### Metadata Failures
- Metadata fetching is non-blocking
- Log debug messages for metadata fetch failures
- Continue with candle fetching even if metadata fails

## Performance Considerations

### API Quota Optimization
- Always fetch maximum 5000 candles per call (same cost as fewer candles)
- Use chunking for long time ranges
- Check ClickHouse first to avoid unnecessary API calls
- Cache metadata to reduce redundant API calls

### Latency Optimization
- ClickHouse queries are faster than API calls
- Use ClickHouse as primary data source when available
- Parallel fetching where possible (1m and 5m can be fetched in parallel)
- Non-blocking metadata fetching

### Storage Optimization
- Store candles with appropriate granularity
- Don't duplicate data (1m candles replace 5m candles in overlapping windows)
- Use time-based partitioning in ClickHouse
- Clean up old cache files periodically

## Testing Requirements

### Unit Tests
- Test 52-period lookback calculation
- Test 5000-candle limit enforcement
- Test chunking logic for long time ranges
- Test ClickHouse query logic
- Test metadata fetching and parsing

### Integration Tests
- Test full fetch flow with ClickHouse
- Test fallback to API when ClickHouse unavailable
- Test metadata enrichment
- Test update strategy (24hr rule, active call exception)

## Market Cap (MCAP) Based Analytics

### Why MCAP Instead of Price

- **Price is misleading**: Token A at $0.001 vs Token B at $100 tells you nothing about performance
- **MCAP is fair**: Both growing from $100K → $1M MCAP = 10x, regardless of token price
- **Use MCAP for multiples**: Calculate multiples as `peak_mcap / entry_mcap`, not just `peak_price / entry_price`

### MCAP Calculation Formula

```typescript
// Calculate peak MCAP from entry MCAP and price change
const peakMcap = entryMcap * (peakPrice / entryPrice);

// Calculate multiple (same as price multiple, but MCAP-contextualized)
const multiple = peakMcap / entryMcap;  // = peakPrice / entryPrice

// Infer entry MCAP if only current data available
const entryMcap = currentMcap * (entryPrice / currentPrice);
```

### Critical Requirements

1. **Always fetch and store entry MCAP at alert time**
   - Use automatic fallback chain (see below)
   - Store in database alongside entry price
   - Field: `entry_mcap` (REAL/FLOAT)

### MCAP Fallback Chain (Automatic)

The system automatically fetches MCAP in this order:

1. **FIRST: Pump.fun/Bonk Detection** (FASTEST - 80% of tokens!)
   - If address ends with `pump` or `bonk` → MCAP = price × 1B
   - Instant, no API calls, 100% reliable
   - Example: `7pXs...pump` at $0.00001 = $10K MCAP

2. **SECOND: Birdeye API**
   - Fetch from `/defi/v3/token/meta-data/single`
   - Most accurate for non-pump tokens

3. **THIRD: Message Extraction**
   - Parse from alert text: "mcap: $500k", "2m mc", etc.
   - Surprisingly effective!

4. **FOURTH: Infer from Current**
   - Calculate: `entry_mcap = current_mcap × (entry_price / current_price)`

5. **FIFTH: Graceful degradation**
   - Price multiples still work without MCAP

**Usage:**
```typescript
import { getEntryMcapWithFallback } from './mcap-calculator';

const mcap = await getEntryMcapWithFallback(
  mint,           // Full, case-preserved address
  'solana',
  timestamp,
  entryPrice,
  messageText     // Provide for extraction step
);
```

2. **Use MCAP for analytics, not raw price**
   - Display: "Entry: $50K → Peak: $5M (100x)"
   - Not: "Entry: $0.0001 → Peak: $0.0100 (100x)"
   - MCAP provides context for the multiple

3. **Calculate peak MCAP from price movement**
   - Don't fetch MCAP at every price point
   - Calculate: `peak_mcap = entry_mcap * (peak_price / entry_price)`
   - More efficient and accurate

4. **Display both MCAP and price**
   - Show MCAP for context
   - Show price for reference
   - Example: "$50K MCAP @ $0.0001" → "$5M MCAP @ $0.0100"

### Implementation Locations

- **MCAP Calculator**: `packages/web/lib/services/mcap-calculator.ts`
- **Performance Metrics**: `packages/web/lib/services/performance-calculator.ts`
- **Analytics Scripts**: `scripts/analysis/score-and-analyze-unified-calls.ts`
- **Documentation**: `docs/MCAP_ANALYTICS.md`

## Code Locations

- **Main Implementation**: `packages/simulation/src/candles.ts`
  - `fetchHybridCandles()`: Main candle fetching function
  - `fetchHybridCandlesWithMetadata()`: Candle fetching with metadata
  - `fetchTokenMetadata()`: Metadata fetching function - **MUST fetch MCAP**
  - `fetchBirdeyeCandles()`: Low-level API call with chunking

- **Storage**: `packages/storage/src/`
  - ClickHouse client and query functions
  - Candle insertion and retrieval
  - **Caller database**: Must store `entry_mcap` field

- **Monitoring**: `packages/monitoring/src/`
  - WebSocket streams for active calls
  - Real-time candle updates
