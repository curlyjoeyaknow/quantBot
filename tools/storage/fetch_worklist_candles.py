#!/usr/bin/env python3
"""
Fetch candles from Birdeye using a coverage worklist.

Reads a worklist JSON generated by generate_coverage_worklist.py and fetches
missing candle data from Birdeye API for each worklist item.

For each worklist item, calculates the time window needed based on the largest
missing window and fetches candles using the quantbot CLI.

Usage:
    python tools/storage/fetch_worklist_candles.py <worklist.json> [--interval 1m] [--dry-run]
"""

import json
import sys
import argparse
import subprocess
from datetime import datetime, timedelta
from typing import Dict, List, Any
from pathlib import Path

TIME_WINDOWS = [12, 24, 36, 48, 72, 96]


def load_worklist(json_path: str) -> Dict[str, Any]:
    """Load worklist JSON from file."""
    with open(json_path, 'r') as f:
        data = json.load(f)
    return data


def calculate_time_window(alert_ts_ms: int, max_missing_window_hours: int) -> tuple[datetime, datetime]:
    """
    Calculate time window to fetch based on alert timestamp and max missing window.
    
    Args:
        alert_ts_ms: Alert timestamp in milliseconds
        max_missing_window_hours: Maximum missing window in hours (e.g., 96 for 96hr)
        
    Returns:
        Tuple of (from_time, to_time) as datetime objects
    """
    alert_dt = datetime.fromtimestamp(alert_ts_ms / 1000)
    
    # Fetch from alert time to alert time + max missing window
    # Add some buffer (e.g., 10% extra) to ensure we get all needed data
    from_time = alert_dt
    to_time = alert_dt + timedelta(hours=int(max_missing_window_hours * 1.1))
    
    return from_time, to_time


def fetch_candles_for_item(
    item: Dict[str, Any],
    interval: str,
    dry_run: bool = False,
    quantbot_cmd: str = 'quantbot'
) -> Dict[str, Any]:
    """
    Fetch candles for a single worklist item using quantbot CLI.
    
    Args:
        item: Worklist item with mint, chain, alert_ts_ms, missing_windows
        interval: Candle interval (1m, 5m, etc.)
        dry_run: If True, only print what would be fetched
        quantbot_cmd: Path to quantbot CLI command
        
    Returns:
        Result dictionary with success status, candles fetched, etc.
    """
    mint = item['mint']
    chain = item['chain']
    alert_ts_ms = item['alert_ts_ms']
    missing_windows = item.get('missing_windows', [])
    
    if not missing_windows:
        return {
            'success': True,
            'skipped': True,
            'reason': 'No missing windows'
        }
    
    # Calculate time window based on largest missing window
    max_missing_window = max(missing_windows)
    from_time, to_time = calculate_time_window(alert_ts_ms, max_missing_window)
    
    if dry_run:
        print(f"[DRY RUN] Would fetch {mint} ({chain}):", file=sys.stderr)
        print(f"  Interval: {interval}", file=sys.stderr)
        print(f"  From: {from_time.isoformat()}", file=sys.stderr)
        print(f"  To: {to_time.isoformat()}", file=sys.stderr)
        print(f"  Missing windows: {missing_windows}", file=sys.stderr)
        return {
            'success': True,
            'dry_run': True
        }
    
    # Build quantbot CLI command
    from_iso = from_time.strftime('%Y-%m-%dT%H:%M:%S')
    to_iso = to_time.strftime('%Y-%m-%dT%H:%M:%S')
    
    cmd = [
        quantbot_cmd,
        'ohlcv', 'fetch',
        '--mint', mint,
        '--chain', chain,
        '--interval', interval,
        '--from', from_iso,
        '--to', to_iso
    ]
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=300  # 5 minute timeout per item
        )
        
        if result.returncode == 0:
            return {
                'success': True,
                'mint': mint,
                'chain': chain,
                'stdout': result.stdout,
                'stderr': result.stderr
            }
        else:
            return {
                'success': False,
                'mint': mint,
                'chain': chain,
                'error': result.stderr,
                'stdout': result.stdout,
                'returncode': result.returncode
            }
    except subprocess.TimeoutExpired:
        return {
            'success': False,
            'mint': mint,
            'chain': chain,
            'error': 'Timeout after 5 minutes'
        }
    except Exception as e:
        return {
            'success': False,
            'mint': mint,
            'chain': chain,
            'error': str(e)
        }


def main():
    """Main script entry point."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        'worklist_json',
        help='Input worklist JSON file from generate_coverage_worklist.py'
    )
    parser.add_argument(
        '--interval',
        default='1m',
        choices=['1m', '5m', '15s', '1H'],
        help='Candle interval to fetch (default: 1m)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Print what would be fetched without actually fetching'
    )
    parser.add_argument(
        '--limit',
        type=int,
        help='Limit number of items to process (for testing)'
    )
    parser.add_argument(
        '--quantbot-cmd',
        default='quantbot',
        help='Path to quantbot CLI command (default: quantbot)'
    )
    parser.add_argument(
        '--rate-limit',
        type=float,
        default=1.0,
        help='Rate limit delay between fetches in seconds (default: 1.0)'
    )
    
    args = parser.parse_args()
    
    try:
        # Load worklist
        print(f"Loading worklist from {args.worklist_json}...", file=sys.stderr)
        worklist_data = load_worklist(args.worklist_json)
        worklist_items = worklist_data.get('worklist', [])
        print(f"âœ“ Loaded {len(worklist_items)} items\n", file=sys.stderr)
        
        if args.limit:
            worklist_items = worklist_items[:args.limit]
            print(f"Limited to {len(worklist_items)} items for testing\n", file=sys.stderr)
        
        if args.dry_run:
            print("DRY RUN MODE - No actual fetches will be performed\n", file=sys.stderr)
        
        # Process each item
        results = []
        successful = 0
        failed = 0
        skipped = 0
        
        for idx, item in enumerate(worklist_items, 1):
            print(f"Processing item {idx}/{len(worklist_items)}: {item['mint'][:16]}...", file=sys.stderr, end=' ')
            
            result = fetch_candles_for_item(
                item,
                args.interval,
                dry_run=args.dry_run,
                quantbot_cmd=args.quantbot_cmd
            )
            
            results.append(result)
            
            if result.get('skipped'):
                print("SKIPPED", file=sys.stderr)
                skipped += 1
            elif result['success']:
                print("SUCCESS", file=sys.stderr)
                successful += 1
            else:
                print(f"FAILED: {result.get('error', 'Unknown error')}", file=sys.stderr)
                failed += 1
            
            # Rate limiting (except for last item)
            if idx < len(worklist_items) and not args.dry_run:
                import time
                time.sleep(args.rate_limit)
        
        # Print summary
        print(f"\n{'='*70}", file=sys.stderr)
        print(f"Summary:", file=sys.stderr)
        print(f"  Total items: {len(worklist_items)}", file=sys.stderr)
        print(f"  Successful: {successful}", file=sys.stderr)
        print(f"  Failed: {failed}", file=sys.stderr)
        print(f"  Skipped: {skipped}", file=sys.stderr)
        print(f"{'='*70}\n", file=sys.stderr)
        
        # Output results as JSON
        output_data = {
            'metadata': {
                'worklist_file': args.worklist_json,
                'interval': args.interval,
                'dry_run': args.dry_run,
                'total_items': len(worklist_items),
                'successful': successful,
                'failed': failed,
                'skipped': skipped
            },
            'results': results
        }
        
        print(json.dumps(output_data, indent=2))
        
        # Exit with error code if any failures
        if failed > 0:
            sys.exit(1)
        
    except FileNotFoundError as e:
        print(f"[error] File not found: {e}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"[error] Invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n[info] Interrupted by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"[error] {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()

