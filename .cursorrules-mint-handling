# Mint Address and Token Handling Rules

## CRITICAL: Mint Address Handling

### NEVER MODIFY MINT ADDRESSES

**ABSOLUTE RULES - NO EXCEPTIONS:**

1. **NEVER concatenate mint addresses**
   - ❌ BAD: `mint.substring(0, 8) + '...'` for logging
   - ❌ BAD: `${mint.slice(0, 10)}...${mint.slice(-10)}`
   - ❌ BAD: Any string manipulation that changes the mint value
   - ✅ GOOD: Use `.substring()` ONLY for display/logging, but ALWAYS pass full mint to functions

2. **NEVER change mint address case**
   - ❌ BAD: `mint.toLowerCase()` when storing or passing to APIs
   - ❌ BAD: `mint.toUpperCase()` 
   - ❌ BAD: Any case transformation on the mint itself
   - ✅ GOOD: Preserve exact case as received from source
   - ✅ GOOD: Use `.toLowerCase()` ONLY for comparison/deduplication, never for storage

3. **NEVER split or join mint addresses**
   - ❌ BAD: `mint.split('').join('')`
   - ❌ BAD: Breaking mint into parts and reassembling
   - ✅ GOOD: Keep mint as single, unmodified string

4. **NEVER truncate mint addresses for storage**
   - ❌ BAD: Storing first 20 characters only
   - ❌ BAD: Removing characters to save space
   - ✅ GOOD: Store complete mint address in database
   - ✅ GOOD: Truncate ONLY for display purposes in UI/logs

### Correct Patterns

```typescript
// ✅ CORRECT: Logging with truncation, but passing full mint
logger.info('Processing token', { 
  mint: mint.substring(0, 20) + '...' // Display only
});
await processToken(mint); // Full mint passed to function

// ✅ CORRECT: Case-insensitive comparison, but preserve original
const isDuplicate = existingMints.some(m => 
  m.toLowerCase() === mint.toLowerCase()
);
if (!isDuplicate) {
  saveMint(mint); // Save original case
}

// ✅ CORRECT: Database storage preserves case
await db.run(
  'INSERT INTO tokens (mint_address) VALUES (?)',
  [mint] // Full, unmodified mint address
);

// ✅ CORRECT: API calls with full mint
const metadata = await birdeyeAPI.getTokenMetadata(mint);
const candles = await fetchCandles(mint, '1m');
```

### Incorrect Patterns to Avoid

```typescript
// ❌ WRONG: Concatenation for storage
const shortMint = mint.substring(0, 20);
await db.run('INSERT INTO tokens (mint) VALUES (?)', [shortMint]);

// ❌ WRONG: Case transformation for storage
await db.run('INSERT INTO tokens (mint) VALUES (?)', [mint.toLowerCase()]);

// ❌ WRONG: String manipulation
const displayMint = mint.slice(0, 8) + '...' + mint.slice(-8);
await processToken(displayMint); // Broken mint!

// ❌ WRONG: Passing truncated mint to API
const metadata = await api.get(mint.substring(0, 30));
```

## Why This Matters

1. **Solana addresses are case-sensitive Base58 strings**
   - Changing case = different address = API failures
   - Truncating = invalid address = failed transactions

2. **Database queries must match exact case**
   - ClickHouse queries use exact string matching
   - Case changes break lookups and create duplicates

3. **API calls require full, exact addresses**
   - Birdeye API: needs full mint for metadata/candles
   - Solana RPC: needs exact address for account lookups
   - Any modification = 404 or invalid response

4. **Deduplication requires care**
   - Compare using `.toLowerCase()` 
   - Store using original case
   - Never save the lowercased version

## Brook7 and Call Extraction Rules

### Case Sensitivity Requirements

1. **Extract mint addresses with exact case from messages**
   ```typescript
   // ✅ CORRECT
   const addresses = text.match(/\b([1-9A-HJ-NP-Za-km-z]{32,44})\b/g);
   for (const mint of addresses) {
     await saveMint(mint); // Original case preserved
   }
   ```

2. **Preserve timestamps exactly**
   ```typescript
   // ✅ CORRECT: ISO format with timezone
   const timestamp = DateTime.fromISO(dateString).toUTC().toISO();
   // Result: "2025-12-05T18:53:22.000Z"
   ```

### Deduplication Strategy

1. **Avoid duplicate bot responses**
   - Filter out: Phanes, Rick, and other bots
   - Check sender name against bot list BEFORE processing

2. **Avoid duplicate calls within time window**
   ```typescript
   // ✅ CORRECT: Case-insensitive comparison for dedup
   const key = mint.toLowerCase();
   if (!seenMints.has(key)) {
     seenMints.set(key, timestamp);
     await saveCall({
       mint: mint, // Original case!
       timestamp,
       caller
     });
   }
   ```

3. **Multiple callers for same token**
   - Each unique caller gets their own record
   - Dedup only within 5-minute window for same caller

## Database Schema Requirements

```sql
-- ✅ CORRECT: Store full mint address
CREATE TABLE tokens (
  mint_address TEXT NOT NULL,  -- Full, case-preserved address
  symbol TEXT,
  timestamp DATETIME NOT NULL
);

-- ❌ WRONG: Truncated mint
CREATE TABLE tokens (
  mint_address VARCHAR(20),  -- Too short!
);
```

## Code Review Checklist

Before committing code that handles mint addresses, verify:

- [ ] No `.toLowerCase()` or `.toUpperCase()` on mints before storage
- [ ] No `.substring()`, `.slice()`, or truncation before API calls
- [ ] No string concatenation that modifies the mint value
- [ ] Database fields are TEXT/VARCHAR with sufficient length (min 44 chars)
- [ ] Logging uses truncation but functions receive full mint
- [ ] Deduplication compares lowercased but stores original
- [ ] API calls receive complete, unmodified mint addresses

## Testing Requirements

1. **Test with real Solana addresses**
   - Mixed case addresses
   - Full 44-character addresses
   - Verify exact case preservation

2. **Test deduplication**
   - Same address with different case should deduplicate
   - But original case should be stored

3. **Test API integration**
   - Verify Birdeye accepts your mint format
   - Check ClickHouse queries return results
   - Confirm no "token not found" errors from case issues

## Common Mistakes and Fixes

| Mistake | Impact | Fix |
|---------|--------|-----|
| `mint.toLowerCase()` before save | Creates wrong address | Save original case |
| `mint.substring(0, 20)` in database | Breaks API calls | Store full 44 chars |
| `${mint.slice(0, 8)}...` to function | Invalid address error | Pass full mint |
| Case-sensitive dedup | Creates duplicates | Compare lowercased, save original |

## Emergency Fix Pattern

If you discover mints are stored with wrong case or truncated:

```typescript
// Re-extract with correct case from source
async function fixMintAddresses() {
  // 1. Get original messages
  const messages = await getOriginalMessages();
  
  // 2. Re-extract with case preservation
  for (const msg of messages) {
    const addresses = extractAddresses(msg.text);
    for (const mint of addresses) {
      // 3. Update with correct case
      await db.run(
        'UPDATE tokens SET mint_address = ? WHERE LOWER(mint_address) = LOWER(?)',
        [mint, mint] // Full, case-preserved mint
      );
    }
  }
}
```

---

**REMEMBER: Mint addresses are like passwords - preserve them exactly as received!**

**When in doubt: LOG with truncation, PASS with full address, STORE with exact case**

