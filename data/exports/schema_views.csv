table_schema,table_name,view_definition
baseline,caller_leaderboard_v,"CREATE VIEW baseline.caller_leaderboard_v AS SELECT run_id, caller, n, median_ath, p75_ath, p95_ath, hit2x_pct, hit3x_pct, hit4x_pct, hit5x_pct, median_t2x_hrs, median_dd_initial_pct, median_dd_overall_pct, median_dd_pre2x_pct, median_dd_pre2x_or_horizon_pct, median_dd_after_2x_pct, median_dd_after_ath_pct, median_peak_pnl_pct, median_ret_end_pct FROM baseline.caller_stats_f ORDER BY run_id, median_ath DESC;"
baseline,caller_leaderboard_v2,"CREATE VIEW baseline.caller_leaderboard_v2 AS WITH caller_ath_stats AS (SELECT run_id, caller, quantile_cont(ath_mult, 0.95) AS p95_ath_computed FROM baseline.alert_results_f WHERE ((status = 'ok') AND (caller IS NOT NULL) AND (caller != '')) GROUP BY run_id, caller)SELECT s.run_id, s.caller, s.n, s.median_ath, s.p75_ath, COALESCE(a.p95_ath_computed, (s.p75_ath * 1.3)) AS p95_ath, s.hit2x_pct, s.hit3x_pct, s.hit4x_pct, s.hit5x_pct, s.median_t2x_hrs, s.median_dd_pre2x_pct, s.median_dd_pre2x_or_horizon_pct, s.median_dd_initial_pct, s.median_dd_overall_pct, s.median_dd_after_2x_pct, s.median_dd_after_3x_pct, s.median_dd_after_ath_pct, s.worst_dd_pct, s.median_peak_pnl_pct, s.median_ret_end_pct FROM baseline.caller_stats_f AS s LEFT JOIN caller_ath_stats AS a ON (((s.run_id = a.run_id) AND (s.caller = a.caller))) ORDER BY s.run_id, s.median_ath DESC;"
baseline,caller_scored_v2,"CREATE VIEW baseline.caller_scored_v2 AS WITH caller_ath_stats AS (SELECT run_id, caller, quantile_cont(ath_mult, 0.75) AS p75_ath_computed, quantile_cont(ath_mult, 0.95) AS p95_ath_computed FROM baseline.alert_results_f WHERE ((status = 'ok') AND (caller IS NOT NULL) AND (caller != '')) GROUP BY run_id, caller), src AS (SELECT s.run_id, s.caller, s.n, s.median_ath, COALESCE(a.p75_ath_computed, s.p75_ath, (s.median_ath * 1.3)) AS p75_ath, COALESCE(a.p95_ath_computed, (s.p75_ath * 1.3), (s.median_ath * 1.8)) AS p95_ath, s.hit2x_pct, s.hit3x_pct, s.hit4x_pct, s.hit5x_pct, s.median_t2x_hrs, COALESCE(s.median_dd_pre2x_or_horizon_pct, s.median_dd_pre2x_pct, s.median_dd_overall_pct) AS risk_dd_pct, s.median_dd_pre2x_pct, s.median_dd_pre2x_or_horizon_pct FROM baseline.caller_stats_f AS s LEFT JOIN caller_ath_stats AS a ON (((s.run_id = a.run_id) AND (s.caller = a.caller)))), feat AS (SELECT *, greatest(0.0, (-(COALESCE(risk_dd_pct, 0.0)) / 100.0)) AS risk_mag, CASE  WHEN ((median_t2x_hrs IS NULL)) THEN (NULL) ELSE (median_t2x_hrs * 60.0) END AS median_t2x_min, (greatest((COALESCE(median_ath, 1.0) - 1.0), 0.0) * (COALESCE(hit2x_pct, 0.0) / 100.0)) AS base_upside, ((0.15 * greatest((COALESCE(p75_ath, median_ath) - COALESCE(median_ath, 1.0)), 0.0)) + (0.10 * greatest((COALESCE(p95_ath, p75_ath) - COALESCE(p75_ath, median_ath)), 0.0))) AS tail_bonus, CASE  WHEN ((median_t2x_hrs IS NULL)) THEN (0.0) ELSE exp((-((median_t2x_hrs * 60.0)) / 60.0)) END AS fast2x_signal, sqrt(((n * 1.0) / (n + 50.0))) AS confidence FROM src), pen AS (SELECT *, CASE  WHEN ((risk_mag <= 0.50)) THEN (0.0) ELSE (exp((8.0 * (risk_mag - 0.50))) - 1.0) END AS risk_penalty, CASE  WHEN (((COALESCE(hit2x_pct, 0.0) >= 40.0) AND (risk_mag <= 0.55))) THEN (0.60) ELSE 0.0 END AS discipline_bonus FROM feat), score AS (SELECT *, (1.0 + (0.80 * fast2x_signal)) AS timing_mult, (confidence * ((((base_upside + tail_bonus) * (1.0 + (0.80 * fast2x_signal))) + discipline_bonus) - (1.00 * risk_penalty))) AS score_v2 FROM pen)SELECT run_id, caller, n, median_ath, p75_ath, p95_ath, hit2x_pct, hit3x_pct, hit4x_pct, hit5x_pct, median_t2x_hrs, median_t2x_min, median_dd_pre2x_pct, median_dd_pre2x_or_horizon_pct, risk_dd_pct, risk_mag, base_upside, tail_bonus, fast2x_signal, discipline_bonus, risk_penalty, confidence, score_v2 FROM score;"
baseline,run_summary_v,"CREATE VIEW baseline.run_summary_v AS SELECT run_id, created_at, run_name, ""chain"", date_from, date_to, interval_seconds, horizon_hours, alerts_total, alerts_ok, json_extract_string(summary_json, '$.median_ath_mult') AS median_ath_mult, json_extract_string(summary_json, '$.pct_hit_2x') AS pct_hit_2x, json_extract_string(summary_json, '$.median_dd_overall') AS median_dd_overall, json_extract_string(summary_json, '$.median_peak_pnl_pct') AS median_peak_pnl_pct FROM baseline.runs_d ORDER BY created_at DESC;"
canon,alert_bot_links,"CREATE VIEW canon.alert_bot_links AS SELECT chat_id AS alert_chat_id, reply_to_message_id AS alert_message_id, message_id AS bot_message_id, ts_ms AS bot_ts_ms, bot_name, run_id, ingested_at FROM canon.bot_cards WHERE (reply_to_message_id IS NOT NULL);"
canon,alert_bot_links_1,"CREATE VIEW canon.alert_bot_links_1 AS SELECT * FROM (SELECT b.*, row_number() OVER (PARTITION BY b.alert_chat_id, b.alert_message_id ORDER BY b.bot_ts_ms ASC, b.ingested_at DESC) AS rn FROM canon.alert_bot_links AS b) WHERE (rn = 1);"
canon,alert_mint_best,"CREATE VIEW canon.alert_mint_best AS WITH m AS (SELECT alert_chat_id, alert_message_id, alert_ts_ms, caller_name, ""chain"", mint, ""source"", run_id, ingested_at, CASE  WHEN ((""chain"" = 'evm')) THEN (regexp_matches(mint, '^0x[0-9a-fA-F]{40}$')) WHEN ((""chain"" = 'solana')) THEN (regexp_matches(mint, '^[1-9A-HJ-NP-Za-km-z]{32,44}$')) ELSE CAST('f' AS BOOLEAN) END AS chain_valid FROM canon.alert_mints), votes AS (SELECT alert_chat_id, alert_message_id, ""chain"", mint, count(DISTINCT ""source"") AS source_count FROM m GROUP BY 1, 2, 3, 4), scored AS (SELECT m.*, v.source_count, (((CASE  WHEN ((m.""source"" = 'bot_card')) THEN (100) ELSE 0 END + CASE  WHEN ((v.source_count >= 2)) THEN (50) ELSE 0 END) + CASE  WHEN (m.chain_valid) THEN (25) ELSE -100 END) + CASE  WHEN ((m.ingested_at IS NOT NULL)) THEN (1) ELSE 0 END) AS score FROM m INNER JOIN votes AS v USING (alert_chat_id, alert_message_id, ""chain"", mint))SELECT * FROM scored QUALIFY (row_number() OVER (PARTITION BY alert_chat_id, alert_message_id ORDER BY score DESC, ""source"" DESC, ingested_at DESC, ""chain"" ASC, mint ASC) = 1);"
canon,alert_mint_counts,"CREATE VIEW canon.alert_mint_counts AS SELECT alert_chat_id, alert_message_id, count_star() AS mint_candidates_n FROM canon.alert_mints GROUP BY 1, 2;"
canon,alert_mint_resolved,"CREATE VIEW canon.alert_mint_resolved AS WITH candidates AS (SELECT alert_chat_id, alert_message_id, ((CAST(alert_chat_id AS VARCHAR) || ':') || CAST(alert_message_id AS VARCHAR)) AS alert_id, mint, ""chain"", ""source"", run_id, ingested_at, CASE  WHEN ((""source"" = 'bot_card')) THEN (0) WHEN ((""source"" = 'alert_text')) THEN (1) ELSE 9 END AS pref_rank FROM canon.alert_mints WHERE ((mint IS NOT NULL) AND (main.""trim""(mint) != ''))), ranked AS (SELECT *, row_number() OVER (PARTITION BY alert_chat_id, alert_message_id ORDER BY pref_rank, ""source"", mint) AS rn FROM candidates)SELECT alert_chat_id, alert_message_id, alert_id, mint, ""chain"", ""source"" AS mint_source, run_id, ingested_at FROM ranked WHERE (rn = 1);"
canon,alert_mints,"CREATE VIEW canon.alert_mints AS WITH from_alert_text AS ((SELECT a.alert_chat_id, a.alert_message_id, a.alert_ts_ms, a.caller_name, a.run_id, a.ingested_at, 'alert_text' AS ""source"", lower(x) AS mint, 'evm' AS ""chain"" FROM canon.alerts AS a , unnest(regexp_extract_all(a.alert_text, '(0x[0-9a-fA-F]{40})', 1)) AS t(x)) UNION ALL (SELECT a.alert_chat_id, a.alert_message_id, a.alert_ts_ms, a.caller_name, a.run_id, a.ingested_at, 'alert_text' AS ""source"", x AS mint, 'solana' AS ""chain"" FROM canon.alerts AS a , unnest(regexp_extract_all(a.alert_text, '([1-9A-HJ-NP-Za-km-z]{32,44})', 1)) AS t(x))), from_bot_cards AS ((SELECT l.alert_chat_id, l.alert_message_id, l.bot_ts_ms AS alert_ts_ms, a.caller_name, l.run_id, l.ingested_at, 'bot_card' AS ""source"", lower(x) AS mint, 'evm' AS ""chain"" FROM canon.alert_bot_links AS l INNER JOIN canon.bot_cards AS b ON (((b.chat_id = l.alert_chat_id) AND (b.message_id = l.bot_message_id))) LEFT JOIN canon.alerts AS a ON (((a.alert_chat_id = l.alert_chat_id) AND (a.alert_message_id = l.alert_message_id))) , unnest(regexp_extract_all(b.bot_text, '(0x[0-9a-fA-F]{40})', 1)) AS t(x)) UNION ALL (SELECT l.alert_chat_id, l.alert_message_id, l.bot_ts_ms AS alert_ts_ms, a.caller_name, l.run_id, l.ingested_at, 'bot_card' AS ""source"", x AS mint, 'solana' AS ""chain"" FROM canon.alert_bot_links AS l INNER JOIN canon.bot_cards AS b ON (((b.chat_id = l.alert_chat_id) AND (b.message_id = l.bot_message_id))) LEFT JOIN canon.alerts AS a ON (((a.alert_chat_id = l.alert_chat_id) AND (a.alert_message_id = l.alert_message_id))) , unnest(regexp_extract_all(b.bot_text, '([1-9A-HJ-NP-Za-km-z]{32,44})', 1)) AS t(x)))SELECT DISTINCT alert_chat_id, alert_message_id, alert_ts_ms, caller_name, ""chain"", mint, ""source"", run_id, ingested_at FROM ((SELECT * FROM from_alert_text) UNION ALL (SELECT * FROM from_bot_cards)) WHERE ((mint IS NOT NULL) AND (mint != ''));"
canon,alert_mints_1,"CREATE VIEW canon.alert_mints_1 AS SELECT alert_chat_id, alert_message_id, mint, ""chain"", ""source"", run_id, ingested_at FROM (SELECT m.*, row_number() OVER (PARTITION BY m.alert_chat_id, m.alert_message_id ORDER BY CASE  WHEN ((m.""source"" = 'bot_card')) THEN (1) WHEN ((m.""source"" = 'alert_text')) THEN (2) ELSE 9 END, m.ingested_at DESC, m.mint ASC) AS rn FROM canon.alert_mints AS m) WHERE (rn = 1);"
canon,alert_resolved,"CREATE VIEW canon.alert_resolved AS WITH mint_ranked AS (SELECT alert_chat_id, alert_message_id, mint, ""chain"", ""source"", run_id, ingested_at, row_number() OVER (PARTITION BY alert_chat_id, alert_message_id ORDER BY CASE  WHEN ((""source"" = 'alert_text')) THEN (1) WHEN ((""source"" = 'bot_card')) THEN (2) ELSE 9 END, ingested_at DESC) AS rn FROM canon.alert_mints)SELECT ((CAST(a.alert_chat_id AS VARCHAR) || ':') || CAST(a.alert_message_id AS VARCHAR)) AS alert_id, a.alert_chat_id, a.alert_message_id, a.alert_ts_ms, a.caller_name, m.""chain"", m.mint, l.bot_message_id, l.bot_ts_ms, l.bot_name, a.run_id, a.ingested_at, a.alert_text FROM canon.alerts AS a LEFT JOIN mint_ranked AS m ON (((m.alert_chat_id = a.alert_chat_id) AND (m.alert_message_id = a.alert_message_id) AND (m.rn = 1))) LEFT JOIN canon.alert_bot_links AS l ON (((l.alert_chat_id = a.alert_chat_id) AND (l.alert_message_id = a.alert_message_id)));"
canon,alert_resolved_light,"CREATE VIEW canon.alert_resolved_light AS SELECT alert_id, alert_ts_ms, caller_name, ""chain"", mint, bot_ts_ms, bot_name, CASE  WHEN (EXISTS(SELECT 1 FROM canon.alert_mints AS m WHERE ((m.alert_chat_id = r.alert_chat_id) AND (m.alert_message_id = r.alert_message_id) AND (m.""source"" = 'alert_text') AND (m.mint = r.mint)))) THEN (CAST('t' AS BOOLEAN)) ELSE CAST('f' AS BOOLEAN) END AS mint_seen_in_alert_text, CASE  WHEN (EXISTS(SELECT 1 FROM canon.alert_mints AS m WHERE ((m.alert_chat_id = r.alert_chat_id) AND (m.alert_message_id = r.alert_message_id) AND (m.""source"" = 'bot_card') AND (m.mint = r.mint)))) THEN (CAST('t' AS BOOLEAN)) ELSE CAST('f' AS BOOLEAN) END AS mint_seen_in_bot_card FROM canon.alert_resolved AS r;"
canon,alerts,"CREATE VIEW canon.alerts AS SELECT CAST(chat_id AS BIGINT) AS alert_chat_id, CAST(message_id AS BIGINT) AS alert_message_id, ((CAST(chat_id AS BIGINT) || ':') || CAST(message_id AS BIGINT)) AS alert_id, CAST(alert_ts_ms AS BIGINT) AS alert_ts_ms, ""nullif""(main.""trim""(from_name), '') AS caller_name, ""text"" AS alert_text, parse_run_id AS run_id, ingested_at FROM core.alerts_d;"
canon,alerts_analysis,"CREATE VIEW canon.alerts_analysis AS SELECT alert_id, alert_chat_id, alert_message_id, alert_ts_ms, ""chain"", mint, mint_source, caller_id, caller_name_norm, caller_base, alert_kind, alert_text, run_id, ingested_at FROM canon.alerts_std WHERE ((caller_id IS NOT NULL) AND (mint IS NOT NULL) AND (mint != ''));"
canon,alerts_canon,"CREATE VIEW canon.alerts_canon AS SELECT ((CAST(u.alert_chat_id AS VARCHAR) || ':') || CAST(u.alert_message_id AS VARCHAR)) AS alert_id, u.alert_chat_id, u.alert_message_id, u.alert_ts_ms, u.alert_kind, mb.""chain"", mb.mint, mb.""source"" AS mint_source, u.caller_name, u.caller_id, u.caller_name_norm, u.caller_base, u.run_id, u.ingested_at, u.alert_text FROM canon.alerts_universe AS u LEFT JOIN canon.alert_mint_best AS mb ON (((mb.alert_chat_id = u.alert_chat_id) AND (mb.alert_message_id = u.alert_message_id)));"
canon,alerts_canon_filled,"CREATE VIEW canon.alerts_canon_filled AS SELECT c.alert_id, c.alert_chat_id, c.alert_message_id, COALESCE(c.alert_ts_ms, m.ts_ms) AS alert_ts_ms, c.alert_kind, c.""chain"", c.mint, c.mint_source, COALESCE(""nullif""(main.""trim""(c.caller_name), ''), ""nullif""(main.""trim""(m.from_name), '')) AS caller_raw_name, COALESCE(c.caller_id, cd.caller_id) AS caller_id, COALESCE(c.caller_name_norm, cd.caller_name) AS caller_name_norm, COALESCE(c.caller_base, cd.caller_base) AS caller_base, c.run_id, c.ingested_at, COALESCE(""nullif""(main.""trim""(c.alert_text), ''), ""nullif""(main.""trim""(m.""text""), '')) AS alert_text FROM canon.alerts_canon AS c LEFT JOIN raw.messages_f AS m ON (((m.chat_id = c.alert_chat_id) AND (m.message_id = c.alert_message_id))) LEFT JOIN canon.callers_d AS cd ON ((cd.caller_raw_name = COALESCE(""nullif""(main.""trim""(c.caller_name), ''), ""nullif""(main.""trim""(m.from_name), ''))));"
canon,alerts_clean,"CREATE VIEW canon.alerts_clean AS SELECT a.*, ""nullif""(main.""trim""(a.caller_name), '') AS caller_raw_name_clean, c.caller_id, c.caller_name AS caller_name_norm, c.caller_base FROM canon.alerts AS a LEFT JOIN canon.callers_d AS c ON ((c.caller_raw_name = ""nullif""(main.""trim""(a.caller_name), '')));"
canon,alerts_enriched,"CREATE VIEW canon.alerts_enriched AS SELECT a.alert_chat_id, a.alert_message_id, a.alert_ts_ms, a.caller_name, m.""chain"", m.mint, l.bot_message_id, l.bot_name, a.alert_text FROM canon.alerts AS a LEFT JOIN canon.alert_mints AS m ON (((m.alert_chat_id = a.alert_chat_id) AND (m.alert_message_id = a.alert_message_id))) LEFT JOIN canon.alert_bot_links AS l ON (((l.alert_chat_id = a.alert_chat_id) AND (l.alert_message_id = a.alert_message_id)));"
canon,alerts_final,"CREATE VIEW canon.alerts_final AS SELECT a.alert_chat_id, a.alert_message_id, a.alert_id, a.alert_ts_ms, a.caller_name, a.caller_id, a.caller_name_norm, b.""chain"", b.mint, b.""source"" AS mint_source, bl.bot_message_id, bl.bot_ts_ms, bl.bot_name, a.run_id, a.ingested_at FROM canon.alerts_clean AS a LEFT JOIN canon.alert_mint_best AS b ON (((b.alert_chat_id = a.alert_chat_id) AND (b.alert_message_id = a.alert_message_id))) LEFT JOIN canon.alert_bot_links AS bl ON (((bl.alert_chat_id = a.alert_chat_id) AND (bl.alert_message_id = a.alert_message_id)));"
canon,alerts_final_pretty,"CREATE VIEW canon.alerts_final_pretty AS SELECT *, to_timestamp((alert_ts_ms / 1000.0)) AS alert_ts_utc FROM canon.alerts_final;"
canon,alerts_health,"CREATE VIEW canon.alerts_health AS SELECT count_star() AS alerts_total, count_star() FILTER (WHERE ((mint IS NOT NULL) AND (mint != ''))) AS alerts_with_mint, count_star() FILTER (WHERE (caller_id IS NOT NULL)) AS alerts_with_caller_id, count_star() FILTER (WHERE (caller_id IS NULL)) AS alerts_missing_caller_id FROM canon.alerts_final;"
canon,alerts_health_origin,"CREATE VIEW canon.alerts_health_origin AS WITH base AS (SELECT a.alert_id, a.alert_kind, a.caller_id, a.caller_raw_name, (m.message_id IS NOT NULL) AS has_raw, ""nullif""(main.""trim""(m.from_name), '') AS raw_from_name FROM canon.alerts_std AS a LEFT JOIN raw.messages_f AS m ON (((m.chat_id = a.alert_chat_id) AND (m.message_id = a.alert_message_id))))SELECT *, CASE  WHEN ((caller_id IS NOT NULL)) THEN ('mapped') WHEN ((has_raw = CAST('f' AS BOOLEAN))) THEN ('unknown_missing_raw') WHEN ((raw_from_name IS NULL)) THEN ('unknown_blank_sender') ELSE 'unknown_other' END AS origin_kind FROM base;"
canon,alerts_promoted_from_raw,"CREATE VIEW canon.alerts_promoted_from_raw AS SELECT CAST(m.chat_id AS BIGINT) AS alert_chat_id, CAST(m.message_id AS BIGINT) AS alert_message_id, CAST(m.ts_ms AS BIGINT) AS alert_ts_ms, m.from_name AS caller_name, m.""text"" AS alert_text, b.run_id, b.ingested_at FROM canon.alert_bot_links AS b INNER JOIN raw.messages_f AS m ON (((m.chat_id = b.alert_chat_id) AND (m.message_id = b.alert_message_id))) LEFT JOIN canon.alerts_clean AS a ON (((a.alert_chat_id = b.alert_chat_id) AND (a.alert_message_id = b.alert_message_id))) WHERE (a.alert_chat_id IS NULL);"
canon,alerts_ready,CREATE VIEW canon.alerts_ready AS SELECT * FROM canon.alerts_std WHERE (caller_id IS NOT NULL);
canon,alerts_resolved,"CREATE VIEW canon.alerts_resolved AS WITH links AS (SELECT a.alert_chat_id, a.alert_message_id, a.alert_id, a.alert_ts_ms, l.bot_message_id, l.bot_ts_ms, l.bot_name, l.run_id, l.ingested_at, row_number() OVER (PARTITION BY a.alert_id ORDER BY CASE  WHEN ((l.bot_ts_ms >= a.alert_ts_ms)) THEN (0) ELSE 1 END, abs((l.bot_ts_ms - a.alert_ts_ms)), l.bot_ts_ms) AS rn FROM canon.alerts_clean AS a LEFT JOIN canon.alert_bot_links AS l ON (((l.alert_chat_id = a.alert_chat_id) AND (l.alert_message_id = a.alert_message_id))))SELECT * EXCLUDE (rn) FROM links WHERE (rn = 1);"
canon,alerts_std,"CREATE VIEW canon.alerts_std AS WITH a AS (SELECT c.alert_id, c.alert_chat_id, c.alert_message_id, c.alert_ts_ms, c.alert_kind, c.mint, c.""chain"", c.mint_source, ""nullif""(main.""trim""(c.caller_name), '') AS canon_caller_raw_name, ""nullif""(main.""trim""(m.from_name), '') AS raw_caller_raw_name, ""nullif""(main.""trim""(m.""text""), '') AS raw_alert_text, m.ts_ms AS raw_ts_ms, c.run_id, c.ingested_at, ""nullif""(main.""trim""(c.alert_text), '') AS canon_alert_text FROM canon.alerts_canon AS c LEFT JOIN raw.messages_f AS m ON (((m.chat_id = c.alert_chat_id) AND (m.message_id = c.alert_message_id)))), picked AS (SELECT alert_id, alert_chat_id, alert_message_id, COALESCE(alert_ts_ms, raw_ts_ms) AS alert_ts_ms, alert_kind, mint, ""chain"", mint_source, COALESCE(canon_caller_raw_name, raw_caller_raw_name) AS caller_raw_name, COALESCE(canon_alert_text, raw_alert_text) AS alert_text, run_id, ingested_at FROM a)SELECT p.*, cd.caller_id, cd.caller_name AS caller_name_norm, cd.caller_base FROM picked AS p LEFT JOIN canon.callers_d AS cd ON ((cd.caller_raw_name = p.caller_raw_name));"
canon,alerts_universe,"CREATE VIEW canon.alerts_universe AS WITH human AS (SELECT a.alert_chat_id, a.alert_message_id, a.alert_ts_ms, a.run_id, a.ingested_at, a.caller_name, a.caller_id, a.caller_name_norm, a.caller_base, a.alert_text, 'human' AS alert_kind FROM canon.alerts_clean AS a), bot_only AS (SELECT b.alert_chat_id, b.alert_message_id, b.bot_ts_ms AS alert_ts_ms, b.run_id, b.ingested_at, CAST(NULL AS VARCHAR) AS caller_name, CAST(NULL AS VARCHAR) AS caller_id, CAST(NULL AS VARCHAR) AS caller_name_norm, CAST(NULL AS VARCHAR) AS caller_base, CAST(NULL AS VARCHAR) AS alert_text, 'bot_only' AS alert_kind FROM canon.alert_bot_links AS b LEFT JOIN canon.alerts_clean AS a ON (((a.alert_chat_id = b.alert_chat_id) AND (a.alert_message_id = b.alert_message_id))) WHERE (a.alert_chat_id IS NULL))(SELECT * FROM human) UNION ALL (SELECT * FROM bot_only);"
canon,alerts_unknown,CREATE VIEW canon.alerts_unknown AS SELECT * FROM canon.alerts_std WHERE (caller_id IS NULL);
canon,alerts_v,"CREATE VIEW canon.alerts_v AS SELECT alert_id, alert_ts_ms, caller_name, ""chain"", mint, bot_ts_ms, bot_name, run_id FROM canon.alert_resolved WHERE ((mint IS NOT NULL) AND (mint != ''));"
canon,bot_cards,"CREATE VIEW canon.bot_cards AS SELECT chat_id, message_id, ts_ms, from_name AS bot_name, ""text"" AS bot_text, reply_to_message_id, run_id, ingested_at FROM canon.messages WHERE (lower(from_name) ~~ '%phanes%');"
canon,messages,"CREATE VIEW canon.messages AS SELECT CAST(chat_id AS BIGINT) AS chat_id, CAST(message_id AS BIGINT) AS message_id, CAST(ts_ms AS BIGINT) AS ts_ms, from_name AS from_name, ""text"" AS ""text"", CAST(reply_to_message_id AS BIGINT) AS reply_to_message_id, parse_run_id AS run_id, ingested_at AS ingested_at, raw_json AS raw_json FROM raw.messages_f;"
information_schema,character_sets,"CREATE TEMP VIEW information_schema.character_sets AS SELECT CAST(NULL AS VARCHAR) AS character_set_catalog, CAST(NULL AS VARCHAR) AS character_set_schema, 'UTF8' AS character_set_name, 'UCS' AS character_repertoire, 'UTF8' AS form_of_use, current_database() AS default_collate_catalog, 'pg_catalog' AS default_collate_schema, 'ucs_basic' AS default_collate_name;"
information_schema,check_constraints,"CREATE TEMP VIEW information_schema.check_constraints AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, CASE  WHEN ((constraint_type = 'NOT NULL')) THEN ((column_name || ' IS NOT NULL')) ELSE constraint_text END AS check_clause FROM (SELECT dc.*, unnest(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE (constraint_type IN ('CHECK', 'NOT NULL')));"
information_schema,columns,"CREATE TEMP VIEW information_schema.""columns"" AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, column_name, column_index AS ordinal_position, column_default, CASE  WHEN (is_nullable) THEN ('YES') ELSE 'NO' END AS is_nullable, data_type, character_maximum_length, CAST(NULL AS INTEGER) AS character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, CAST(NULL AS INTEGER) AS datetime_precision, CAST(NULL AS VARCHAR) AS interval_type, CAST(NULL AS INTEGER) AS interval_precision, CAST(NULL AS VARCHAR) AS character_set_catalog, CAST(NULL AS VARCHAR) AS character_set_schema, CAST(NULL AS VARCHAR) AS character_set_name, CAST(NULL AS VARCHAR) AS collation_catalog, CAST(NULL AS VARCHAR) AS collation_schema, CAST(NULL AS VARCHAR) AS collation_name, CAST(NULL AS VARCHAR) AS domain_catalog, CAST(NULL AS VARCHAR) AS domain_schema, CAST(NULL AS VARCHAR) AS domain_name, CAST(NULL AS VARCHAR) AS udt_catalog, CAST(NULL AS VARCHAR) AS udt_schema, CAST(NULL AS VARCHAR) AS udt_name, CAST(NULL AS VARCHAR) AS scope_catalog, CAST(NULL AS VARCHAR) AS scope_schema, CAST(NULL AS VARCHAR) AS scope_name, CAST(NULL AS BIGINT) AS maximum_cardinality, CAST(NULL AS VARCHAR) AS dtd_identifier, CAST(NULL AS BOOLEAN) AS is_self_referencing, CAST(NULL AS BOOLEAN) AS is_identity, CAST(NULL AS VARCHAR) AS identity_generation, CAST(NULL AS VARCHAR) AS identity_start, CAST(NULL AS VARCHAR) AS identity_increment, CAST(NULL AS VARCHAR) AS identity_maximum, CAST(NULL AS VARCHAR) AS identity_minimum, CAST(NULL AS BOOLEAN) AS identity_cycle, CAST(NULL AS VARCHAR) AS is_generated, CAST(NULL AS VARCHAR) AS generation_expression, CAST(NULL AS BOOLEAN) AS is_updatable, ""comment"" AS COLUMN_COMMENT FROM duckdb_columns;"
information_schema,constraint_column_usage,"CREATE TEMP VIEW information_schema.constraint_column_usage AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, column_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type, constraint_text FROM (SELECT dc.*, unnest(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE (constraint_type NOT IN ('NOT NULL')));"
information_schema,constraint_table_usage,"CREATE TEMP VIEW information_schema.constraint_table_usage AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type FROM duckdb_constraints() WHERE (constraint_type NOT IN ('NOT NULL'));"
information_schema,key_column_usage,"CREATE TEMP VIEW information_schema.key_column_usage AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, database_name AS table_catalog, schema_name AS table_schema, table_name, unnest(constraint_column_names) AS column_name, unnest(generate_series(1, len(constraint_column_names))) AS ordinal_position, CASE  WHEN ((constraint_type = 'FOREIGN KEY')) THEN (1) ELSE NULL END AS position_in_unique_constraint FROM duckdb_constraints() WHERE ((constraint_type = 'FOREIGN KEY') OR (constraint_type = 'PRIMARY KEY') OR (constraint_type = 'UNIQUE'));"
information_schema,referential_constraints,"CREATE TEMP VIEW information_schema.referential_constraints AS SELECT f.database_name AS constraint_catalog, f.schema_name AS constraint_schema, f.constraint_name AS constraint_name, c.database_name AS unique_constraint_catalog, c.schema_name AS unique_constraint_schema, c.constraint_name AS unique_constraint_name, 'NONE' AS match_option, 'NO ACTION' AS update_rule, 'NO ACTION' AS delete_rule FROM duckdb_constraints() AS c , duckdb_constraints() AS f WHERE ((f.constraint_type = 'FOREIGN KEY') AND ((c.constraint_type = 'UNIQUE') OR (c.constraint_type = 'PRIMARY KEY')) AND (f.database_oid = c.database_oid) AND (f.schema_oid = c.schema_oid) AND (lower(f.referenced_table) = lower(c.table_name)) AND (main.list_apply(f.referenced_column_names, (lambda x: lower(x))) = main.list_apply(c.constraint_column_names, (lambda x: lower(x)))));"
information_schema,schemata,"CREATE TEMP VIEW information_schema.schemata AS SELECT database_name AS catalog_name, schema_name, 'duckdb' AS schema_owner, CAST(NULL AS VARCHAR) AS default_character_set_catalog, CAST(NULL AS VARCHAR) AS default_character_set_schema, CAST(NULL AS VARCHAR) AS default_character_set_name, ""sql"" AS sql_path FROM duckdb_schemas();"
information_schema,table_constraints,"CREATE TEMP VIEW information_schema.table_constraints AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, database_name AS table_catalog, schema_name AS table_schema, table_name, CASE  WHEN ((constraint_type = 'NOT NULL')) THEN ('CHECK') ELSE constraint_type END AS constraint_type, 'NO' AS is_deferrable, 'NO' AS initially_deferred, 'YES' AS enforced, 'YES' AS nulls_distinct FROM duckdb_constraints() WHERE ((constraint_type = 'PRIMARY KEY') OR (constraint_type = 'FOREIGN KEY') OR (constraint_type = 'UNIQUE') OR (constraint_type = 'CHECK') OR (constraint_type = 'NOT NULL'));"
information_schema,tables,"CREATE TEMP VIEW information_schema.""tables"" AS (SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, CASE  WHEN (""temporary"") THEN ('LOCAL TEMPORARY') ELSE 'BASE TABLE' END AS table_type, CAST(NULL AS VARCHAR) AS self_referencing_column_name, CAST(NULL AS VARCHAR) AS reference_generation, CAST(NULL AS VARCHAR) AS user_defined_type_catalog, CAST(NULL AS VARCHAR) AS user_defined_type_schema, CAST(NULL AS VARCHAR) AS user_defined_type_name, 'YES' AS is_insertable_into, 'NO' AS is_typed, CASE  WHEN (""temporary"") THEN ('PRESERVE') ELSE NULL END AS commit_action, ""comment"" AS TABLE_COMMENT FROM duckdb_tables()) UNION ALL (SELECT database_name AS table_catalog, schema_name AS table_schema, view_name AS table_name, 'VIEW' AS table_type, NULL AS self_referencing_column_name, NULL AS reference_generation, NULL AS user_defined_type_catalog, NULL AS user_defined_type_schema, NULL AS user_defined_type_name, 'NO' AS is_insertable_into, 'NO' AS is_typed, NULL AS commit_action, ""comment"" AS TABLE_COMMENT FROM duckdb_views);"
information_schema,views,"CREATE TEMP VIEW information_schema.""views"" AS SELECT database_name AS table_catalog, schema_name AS table_schema, view_name AS table_name, ""sql"" AS view_definition, 'NONE' AS check_option, 'NO' AS is_updatable, 'NO' AS is_insertable_into, 'NO' AS is_trigger_updatable, 'NO' AS is_trigger_deletable, 'NO' AS is_trigger_insertable_into FROM duckdb_views();"
main,alerts_missing_coverage,"CREATE VIEW alerts_missing_coverage AS SELECT chat_id, message_id, trigger_ts_ms, caller_name, mint, ""chain"", coverage_ratio, expected_candles, actual_candles, last_checked_at FROM ohlcv_coverage_matrix WHERE ((has_ohlcv_data = CAST('f' AS BOOLEAN)) OR (coverage_ratio < 0.8)) ORDER BY trigger_ts_ms DESC;"
main,caller_coverage_summary,"CREATE VIEW caller_coverage_summary AS SELECT caller_name, count_star() AS total_calls, count_star() FILTER (WHERE (has_ohlcv_data = CAST('t' AS BOOLEAN))) AS calls_with_coverage, count_star() FILTER (WHERE (has_ohlcv_data = CAST('f' AS BOOLEAN))) AS calls_without_coverage, avg(coverage_ratio) AS avg_coverage_ratio, min(coverage_ratio) AS min_coverage_ratio, max(coverage_ratio) AS max_coverage_ratio, min(trigger_ts_ms) AS first_call_ts_ms, max(trigger_ts_ms) AS last_call_ts_ms FROM ohlcv_coverage_matrix WHERE (caller_name IS NOT NULL) GROUP BY caller_name;"
main,caller_monthly_coverage,"CREATE VIEW caller_monthly_coverage AS SELECT caller_name, strftime(to_timestamp((trigger_ts_ms / 1000)), '%Y-%m') AS ""month"", count_star() AS total_calls, count_star() FILTER (WHERE (has_ohlcv_data = CAST('t' AS BOOLEAN))) AS calls_with_coverage, count_star() FILTER (WHERE (has_ohlcv_data = CAST('f' AS BOOLEAN))) AS calls_without_coverage, (CAST(count_star() FILTER (WHERE (has_ohlcv_data = CAST('t' AS BOOLEAN))) AS DOUBLE) / count_star()) AS coverage_ratio, avg(coverage_ratio) AS avg_coverage_ratio FROM ohlcv_coverage_matrix WHERE (caller_name IS NOT NULL) GROUP BY caller_name, ""month"" ORDER BY caller_name, ""month"";"
main,duckdb_columns,CREATE TEMP VIEW duckdb_columns AS SELECT * FROM duckdb_columns() WHERE (NOT internal);
main,duckdb_constraints,CREATE TEMP VIEW duckdb_constraints AS SELECT * FROM duckdb_constraints();
main,duckdb_databases,CREATE TEMP VIEW duckdb_databases AS SELECT * FROM duckdb_databases() WHERE (NOT internal);
main,duckdb_indexes,CREATE TEMP VIEW duckdb_indexes AS SELECT * FROM duckdb_indexes();
main,duckdb_logs,CREATE TEMP VIEW duckdb_logs AS SELECT * FROM duckdb_logs((denormalized_table = CAST('t' AS BOOLEAN)));
main,duckdb_schemas,CREATE TEMP VIEW duckdb_schemas AS SELECT * FROM duckdb_schemas() WHERE (NOT internal);
main,duckdb_tables,CREATE TEMP VIEW duckdb_tables AS SELECT * FROM duckdb_tables() WHERE (NOT internal);
main,duckdb_types,CREATE TEMP VIEW duckdb_types AS SELECT * FROM duckdb_types();
main,duckdb_views,CREATE TEMP VIEW duckdb_views AS SELECT * FROM duckdb_views() WHERE (NOT internal);
main,pragma_database_list,"CREATE TEMP VIEW pragma_database_list AS SELECT database_oid AS seq, database_name AS ""name"", path AS file FROM duckdb_databases() WHERE (NOT internal) ORDER BY 1;"
main,sqlite_master,"CREATE TEMP VIEW sqlite_master AS ((SELECT 'table' AS ""type"", table_name AS ""name"", table_name AS tbl_name, 0 AS rootpage, ""sql"" FROM duckdb_tables) UNION ALL (SELECT 'view' AS ""type"", view_name AS ""name"", view_name AS tbl_name, 0 AS rootpage, ""sql"" FROM duckdb_views)) UNION ALL (SELECT 'index' AS ""type"", index_name AS ""name"", table_name AS tbl_name, 0 AS rootpage, ""sql"" FROM duckdb_indexes);"
main,sqlite_schema,CREATE TEMP VIEW sqlite_schema AS SELECT * FROM sqlite_master;
main,sqlite_temp_master,CREATE TEMP VIEW sqlite_temp_master AS SELECT * FROM sqlite_master;
main,sqlite_temp_schema,CREATE TEMP VIEW sqlite_temp_schema AS SELECT * FROM sqlite_master;
main,token_coverage_summary,"CREATE VIEW token_coverage_summary AS SELECT mint, ""chain"", count_star() AS total_alerts, count_star() FILTER (WHERE (has_ohlcv_data = CAST('t' AS BOOLEAN))) AS alerts_with_coverage, count_star() FILTER (WHERE (has_ohlcv_data = CAST('f' AS BOOLEAN))) AS alerts_without_coverage, avg(coverage_ratio) AS avg_coverage_ratio, min(coverage_ratio) AS min_coverage_ratio, max(coverage_ratio) AS max_coverage_ratio, min(trigger_ts_ms) AS first_alert_ts_ms, max(trigger_ts_ms) AS last_alert_ts_ms FROM ohlcv_coverage_matrix GROUP BY mint, ""chain"";"
optimizer,best_trials_v,"CREATE VIEW optimizer.best_trials_v AS SELECT t.run_id, t.trial_id, t.strategy_name, t.tp_mult, t.sl_mult, t.total_r, t.avg_r, t.win_rate, t.hit2x_pct, t.median_ath_mult, t.median_dd_pre2x, t.median_time_to_2x_min, t.objective_score, t.risk_adj_total_return_pct, t.duration_ms, row_number() OVER (PARTITION BY t.run_id ORDER BY t.objective_score DESC NULLS LAST) AS rank_by_objective, row_number() OVER (PARTITION BY t.run_id ORDER BY t.total_r DESC) AS rank_by_total_r FROM optimizer.trials_f AS t ORDER BY t.run_id, t.objective_score DESC NULLS LAST;"
optimizer,overfit_check_v,"CREATE VIEW optimizer.overfit_check_v AS SELECT r.run_id, r.run_type, r.""name"", count(DISTINCT t.trial_id) AS n_trials, avg(t.objective_score) AS avg_objective, max(t.objective_score) AS best_objective, avg(t.hit2x_pct) AS avg_hit2x, avg(t.median_dd_pre2x) AS avg_dd_pre2x, avg(t.median_time_to_2x_min) AS avg_time_to_2x, r.created_at FROM optimizer.runs_d AS r LEFT JOIN optimizer.trials_f AS t ON ((t.run_id = r.run_id)) GROUP BY r.run_id, r.run_type, r.""name"", r.created_at ORDER BY r.created_at DESC;"
optimizer,pipeline_status_v,"CREATE VIEW optimizer.pipeline_status_v AS SELECT r.run_id, r.run_type, r.""name"", r.created_at, p.phase_name, p.phase_order, p.status AS phase_status, p.started_at, p.completed_at, p.duration_ms, p.error_message FROM optimizer.runs_d AS r LEFT JOIN optimizer.pipeline_phases_f AS p ON ((p.run_id = r.run_id)) ORDER BY r.created_at DESC, p.phase_order;"
optimizer,recent_runs_v,"CREATE VIEW optimizer.recent_runs_v AS SELECT run_id, run_type, created_at, ""name"", date_from, date_to, alerts_total, (SELECT count_star() FROM optimizer.trials_f AS t WHERE (t.run_id = r.run_id)) AS n_trials, (SELECT count_star() FROM optimizer.walk_forward_f AS w WHERE (w.run_id = r.run_id)) AS n_folds, CAST(json_extract_string(timing_json, '$.total_ms') AS INTEGER) AS total_ms FROM optimizer.runs_d AS r ORDER BY created_at DESC LIMIT 100;"
optimizer,validation_summary_v,"CREATE VIEW optimizer.validation_summary_v AS SELECT v.run_id, v.champion_id, c.island_id, c.tp_mult, c.sl_mult, c.discovery_score, v.robust_score AS validation_score, v.score_delta, v.worst_lane, v.worst_lane_score, v.lanes_passing, v.n_lanes, v.validation_rank, CASE  WHEN ((v.validation_rank = 1)) THEN ('WINNER') ELSE '' END AS status FROM optimizer.champion_validation_f AS v INNER JOIN optimizer.island_champions_f AS c ON ((c.champion_id = v.champion_id)) ORDER BY v.run_id, v.validation_rank;"
optimizer,walk_forward_summary_v,"CREATE VIEW optimizer.walk_forward_summary_v AS SELECT run_id, count_star() AS n_folds, avg(train_total_r) AS avg_train_r, avg(test_total_r) AS avg_test_r, median(test_total_r) AS median_test_r, avg(delta_total_r) AS avg_delta_r, sum(CASE  WHEN ((test_total_r > 0)) THEN (1) ELSE 0 END) AS folds_profitable, sum(CASE  WHEN ((delta_total_r > 0)) THEN (1) ELSE 0 END) AS folds_improved, min(test_total_r) AS worst_fold_r FROM optimizer.walk_forward_f GROUP BY run_id;"
pg_catalog,pg_am,"CREATE TEMP VIEW pg_catalog.pg_am AS SELECT 0 AS oid, 'art' AS amname, NULL AS amhandler, 'i' AS amtype;"
pg_catalog,pg_attrdef,"CREATE TEMP VIEW pg_catalog.pg_attrdef AS SELECT column_index AS oid, table_oid AS adrelid, column_index AS adnum, column_default AS adbin FROM duckdb_columns() WHERE (column_default IS NOT NULL);"
pg_catalog,pg_attribute,"CREATE TEMP VIEW pg_catalog.pg_attribute AS SELECT table_oid AS attrelid, column_name AS attname, data_type_id AS atttypid, 0 AS attstattarget, NULL AS attlen, column_index AS attnum, 0 AS attndims, -1 AS attcacheoff, CASE  WHEN ((data_type ~~* '%decimal%')) THEN (((numeric_precision * 1000) + numeric_scale)) ELSE -1 END AS atttypmod, CAST('f' AS BOOLEAN) AS attbyval, NULL AS attstorage, NULL AS attalign, (NOT is_nullable) AS attnotnull, (column_default IS NOT NULL) AS atthasdef, CAST('f' AS BOOLEAN) AS atthasmissing, '' AS attidentity, '' AS attgenerated, CAST('f' AS BOOLEAN) AS attisdropped, CAST('t' AS BOOLEAN) AS attislocal, 0 AS attinhcount, 0 AS attcollation, NULL AS attcompression, NULL AS attacl, NULL AS attoptions, NULL AS attfdwoptions, NULL AS attmissingval FROM duckdb_columns();"
pg_catalog,pg_class,"CREATE TEMP VIEW pg_catalog.pg_class AS (((SELECT table_oid AS oid, table_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, CAST(estimated_size AS FLOAT) AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, (index_count > 0) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN (""temporary"") THEN ('t') ELSE 'p' END AS relpersistence, 'r' AS relkind, column_count AS relnatts, check_constraint_count AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, has_primary_key AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_tables()) UNION ALL (SELECT view_oid AS oid, view_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN (""temporary"") THEN ('t') ELSE 'p' END AS relpersistence, 'v' AS relkind, column_count AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_views())) UNION ALL (SELECT sequence_oid AS oid, sequence_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN (""temporary"") THEN ('t') ELSE 'p' END AS relpersistence, 'S' AS relkind, 0 AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_sequences())) UNION ALL (SELECT index_oid AS oid, index_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, 't' AS relpersistence, 'i' AS relkind, NULL AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_indexes());"
pg_catalog,pg_constraint,"CREATE TEMP VIEW pg_catalog.pg_constraint AS SELECT ((table_oid * 1000000) + constraint_index) AS oid, constraint_text AS conname, schema_oid AS connamespace, CASE  WHEN ((constraint_type = 'CHECK')) THEN ('c') WHEN ((constraint_type = 'UNIQUE')) THEN ('u') WHEN ((constraint_type = 'PRIMARY KEY')) THEN ('p') WHEN ((constraint_type = 'FOREIGN KEY')) THEN ('f') ELSE 'x' END AS contype, CAST('f' AS BOOLEAN) AS condeferrable, CAST('f' AS BOOLEAN) AS condeferred, CAST('t' AS BOOLEAN) AS convalidated, table_oid AS conrelid, 0 AS contypid, 0 AS conindid, 0 AS conparentid, 0 AS confrelid, NULL AS confupdtype, NULL AS confdeltype, NULL AS confmatchtype, CAST('t' AS BOOLEAN) AS conislocal, 0 AS coninhcount, CAST('f' AS BOOLEAN) AS connoinherit, constraint_column_indexes AS conkey, NULL AS confkey, NULL AS conpfeqop, NULL AS conppeqop, NULL AS conffeqop, NULL AS conexclop, expression AS conbin FROM duckdb_constraints();"
pg_catalog,pg_database,"CREATE TEMP VIEW pg_catalog.pg_database AS SELECT database_oid AS oid, database_name AS datname FROM duckdb_databases();"
pg_catalog,pg_depend,CREATE TEMP VIEW pg_catalog.pg_depend AS SELECT * FROM duckdb_dependencies();
pg_catalog,pg_description,"CREATE TEMP VIEW pg_catalog.pg_description AS ((((((SELECT table_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_tables() WHERE (NOT internal)) UNION ALL (SELECT table_oid AS objoid, database_oid AS classoid, column_index AS objsubid, ""comment"" AS description FROM duckdb_columns() WHERE (NOT internal))) UNION ALL (SELECT view_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_views() WHERE (NOT internal))) UNION ALL (SELECT index_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_indexes)) UNION ALL (SELECT sequence_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_sequences())) UNION ALL (SELECT type_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_types() WHERE (NOT internal))) UNION ALL (SELECT function_oid AS objoid, database_oid AS classoid, 0 AS objsubid, ""comment"" AS description FROM duckdb_functions() WHERE (NOT internal));"
pg_catalog,pg_enum,"CREATE TEMP VIEW pg_catalog.pg_enum AS SELECT NULL AS oid, a.type_oid AS enumtypid, list_position(b.labels, a.elabel) AS enumsortorder, a.elabel AS enumlabel FROM (SELECT unnest(labels) AS elabel, type_oid FROM duckdb_types() WHERE (logical_type = 'ENUM')) AS a INNER JOIN duckdb_types() AS b ON ((a.type_oid = b.type_oid));"
pg_catalog,pg_index,"CREATE TEMP VIEW pg_catalog.pg_index AS SELECT index_oid AS indexrelid, table_oid AS indrelid, 0 AS indnatts, 0 AS indnkeyatts, is_unique AS indisunique, is_primary AS indisprimary, CAST('f' AS BOOLEAN) AS indisexclusion, CAST('t' AS BOOLEAN) AS indimmediate, CAST('f' AS BOOLEAN) AS indisclustered, CAST('t' AS BOOLEAN) AS indisvalid, CAST('f' AS BOOLEAN) AS indcheckxmin, CAST('t' AS BOOLEAN) AS indisready, CAST('t' AS BOOLEAN) AS indislive, CAST('f' AS BOOLEAN) AS indisreplident, CAST(NULL AS INTEGER[]) AS indkey, CAST(NULL AS BIGINT[]) AS indcollation, CAST(NULL AS BIGINT[]) AS indclass, CAST(NULL AS INTEGER[]) AS indoption, expressions AS indexprs, NULL AS indpred FROM duckdb_indexes();"
pg_catalog,pg_indexes,"CREATE TEMP VIEW pg_catalog.pg_indexes AS SELECT schema_name AS schemaname, table_name AS tablename, index_name AS indexname, NULL AS ""tablespace"", ""sql"" AS indexdef FROM duckdb_indexes();"
pg_catalog,pg_namespace,"CREATE TEMP VIEW pg_catalog.pg_namespace AS SELECT oid, schema_name AS nspname, 0 AS nspowner, NULL AS nspacl FROM duckdb_schemas() WHERE (database_name = current_database());"
pg_catalog,pg_prepared_statements,"CREATE TEMP VIEW pg_catalog.pg_prepared_statements AS SELECT ""name"", ""statement"", NULL AS prepare_time, parameter_types, result_types, NULL AS from_sql, NULL AS generic_plans, NULL AS custom_plans FROM duckdb_prepared_statements();"
pg_catalog,pg_proc,"CREATE TEMP VIEW pg_catalog.pg_proc AS SELECT f.function_oid AS oid, function_name AS proname, s.oid AS pronamespace, NULL AS proowner, NULL AS prolang, 0 AS procost, 0 AS prorows, varargs AS provariadic, 0 AS prosupport, CASE  WHEN ((function_type = 'aggregate')) THEN ('a') ELSE 'f' END AS prokind, CAST('f' AS BOOLEAN) AS prosecdef, CAST('f' AS BOOLEAN) AS proleakproof, CAST('f' AS BOOLEAN) AS proisstrict, (function_type = 'table') AS proretset, CASE  WHEN ((stability = 'CONSISTENT')) THEN ('i') WHEN ((stability = 'CONSISTENT_WITHIN_QUERY')) THEN ('s') WHEN ((stability = 'VOLATILE')) THEN ('v') ELSE NULL END AS provolatile, 'u' AS proparallel, length(parameters) AS pronargs, 0 AS pronargdefaults, return_type AS prorettype, parameter_types AS proargtypes, NULL AS proallargtypes, NULL AS proargmodes, parameters AS proargnames, NULL AS proargdefaults, NULL AS protrftypes, NULL AS prosrc, NULL AS probin, macro_definition AS prosqlbody, NULL AS proconfig, NULL AS proacl, (function_type = 'aggregate') AS proisagg FROM duckdb_functions() AS f LEFT JOIN duckdb_schemas() AS s USING (database_name, schema_name);"
pg_catalog,pg_sequence,"CREATE TEMP VIEW pg_catalog.pg_sequence AS SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, ""cycle"" AS seqcycle FROM duckdb_sequences();"
pg_catalog,pg_sequences,"CREATE TEMP VIEW pg_catalog.pg_sequences AS SELECT schema_name AS schemaname, sequence_name AS sequencename, 'duckdb' AS sequenceowner, 0 AS data_type, start_value, min_value, max_value, increment_by, ""cycle"", 0 AS cache_size, last_value FROM duckdb_sequences();"
pg_catalog,pg_settings,"CREATE TEMP VIEW pg_catalog.pg_settings AS SELECT ""name"", ""value"" AS setting, description AS short_desc, CASE  WHEN ((input_type = 'VARCHAR')) THEN ('string') WHEN ((input_type = 'BOOLEAN')) THEN ('bool') WHEN ((input_type IN ('BIGINT', 'UBIGINT'))) THEN ('integer') ELSE input_type END AS vartype FROM duckdb_settings();"
pg_catalog,pg_tables,"CREATE TEMP VIEW pg_catalog.pg_tables AS SELECT schema_name AS schemaname, table_name AS tablename, 'duckdb' AS tableowner, NULL AS ""tablespace"", (index_count > 0) AS hasindexes, CAST('f' AS BOOLEAN) AS hasrules, CAST('f' AS BOOLEAN) AS hastriggers FROM duckdb_tables();"
pg_catalog,pg_tablespace,"CREATE TEMP VIEW pg_catalog.pg_tablespace AS SELECT 0 AS oid, 'pg_default' AS spcname, 0 AS spcowner, NULL AS spcacl, NULL AS spcoptions;"
pg_catalog,pg_type,"CREATE TEMP VIEW pg_catalog.pg_type AS SELECT CASE  WHEN ((type_oid IS NULL)) THEN (NULL) WHEN (((logical_type = 'ENUM') AND (type_name != 'enum'))) THEN (type_oid) ELSE map_to_pg_oid(type_name) END AS oid, format_pg_type(logical_type, type_name) AS typname, schema_oid AS typnamespace, 0 AS typowner, type_size AS typlen, CAST('f' AS BOOLEAN) AS typbyval, CASE  WHEN ((logical_type = 'ENUM')) THEN ('e') ELSE 'b' END AS typtype, CASE  WHEN ((type_category = 'NUMERIC')) THEN ('N') WHEN ((type_category = 'STRING')) THEN ('S') WHEN ((type_category = 'DATETIME')) THEN ('D') WHEN ((type_category = 'BOOLEAN')) THEN ('B') WHEN ((type_category = 'COMPOSITE')) THEN ('C') WHEN ((type_category = 'USER')) THEN ('U') ELSE 'X' END AS typcategory, CAST('f' AS BOOLEAN) AS typispreferred, CAST('t' AS BOOLEAN) AS typisdefined, NULL AS typdelim, NULL AS typrelid, NULL AS typsubscript, NULL AS typelem, NULL AS typarray, NULL AS typinput, NULL AS typoutput, NULL AS typreceive, NULL AS typsend, NULL AS typmodin, NULL AS typmodout, NULL AS typanalyze, 'd' AS typalign, 'p' AS typstorage, NULL AS typnotnull, NULL AS typbasetype, NULL AS typtypmod, NULL AS typndims, NULL AS typcollation, NULL AS typdefaultbin, NULL AS typdefault, NULL AS typacl FROM duckdb_types() WHERE (type_oid IS NOT NULL);"
pg_catalog,pg_views,"CREATE TEMP VIEW pg_catalog.pg_views AS SELECT schema_name AS schemaname, view_name AS viewname, 'duckdb' AS viewowner, ""sql"" AS definition FROM duckdb_views();"
