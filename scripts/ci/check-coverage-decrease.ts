#!/usr/bin/env tsx

/**
 * Coverage Decrease Prevention Script
 *
 * Prevents coverage from decreasing below baseline.
 * Compares current coverage against baseline stored in coverage/.baseline.json
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { execSync } from 'node:child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = join(__filename, '..', '..');
const ROOT = __dirname;

interface CoverageMetrics {
  lines: number;
  functions: number;
  branches: number;
  statements: number;
}

interface CoverageReport {
  total: CoverageMetrics;
  packages: Record<string, CoverageMetrics>;
}

/**
 * Read coverage baseline from file
 */
function readBaseline(): CoverageMetrics | null {
  const baselinePath = join(ROOT, 'coverage', '.baseline.json');
  if (!existsSync(baselinePath)) {
    return null;
  }

  try {
    const content = readFileSync(baselinePath, 'utf-8');
    const baseline = JSON.parse(content);
    return {
      lines: baseline.lines || 0,
      functions: baseline.functions || 0,
      branches: baseline.branches || 0,
      statements: baseline.statements || 0,
    };
  } catch {
    return null;
  }
}

/**
 * Write coverage baseline to file
 */
function writeBaseline(metrics: CoverageMetrics): void {
  const coverageDir = join(ROOT, 'coverage');
  if (!existsSync(coverageDir)) {
    mkdirSync(coverageDir, { recursive: true });
  }

  const baselinePath = join(coverageDir, '.baseline.json');
  writeFileSync(baselinePath, JSON.stringify(metrics, null, 2) + '\n');
}

/**
 * Parse coverage from lcov or JSON report
 */
function parseCoverageReport(): CoverageMetrics | null {
  // Try to read from coverage/coverage-summary.json (generated by vitest)
  const summaryPath = join(ROOT, 'coverage', 'coverage-summary.json');
  if (existsSync(summaryPath)) {
    try {
      const summary = JSON.parse(readFileSync(summaryPath, 'utf-8'));
      const total = summary.total || {};
      return {
        lines: total.lines?.pct || 0,
        functions: total.functions?.pct || 0,
        branches: total.branches?.pct || 0,
        statements: total.statements?.pct || 0,
      };
    } catch {
      // Fall through to lcov parsing
    }
  }

  // Try to parse from lcov.info
  const lcovPath = join(ROOT, 'coverage', 'lcov.info');
  if (existsSync(lcovPath)) {
    try {
      const lcovContent = readFileSync(lcovPath, 'utf-8');
      return parseLcov(lcovContent);
    } catch {
      // Fall through
    }
  }

  // Try to run coverage and parse output
  try {
    const output = execSync('pnpm test:coverage', { encoding: 'utf-8', cwd: ROOT, stdio: 'pipe' });
    // Try to extract coverage from output
    const match = output.match(/Statements\s+:\s+(\d+\.\d+)%\s+\((\d+)\/(\d+)\)/);
    if (match) {
      // Re-read summary after running
      return parseCoverageReport();
    }
  } catch {
    // Coverage run failed
  }

  return null;
}

/**
 * Parse LCOV format
 */
function parseLcov(content: string): CoverageMetrics | null {
  let totalLines = 0;
  let coveredLines = 0;
  let totalFunctions = 0;
  let coveredFunctions = 0;
  let totalBranches = 0;
  let coveredBranches = 0;

  const lines = content.split('\n');
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('LF:')) {
      // Lines found
      totalLines += parseInt(line.split(':')[1] || '0', 10);
    } else if (line.startsWith('LH:')) {
      // Lines hit
      coveredLines += parseInt(line.split(':')[1] || '0', 10);
    } else if (line.startsWith('FNF:')) {
      // Functions found
      totalFunctions += parseInt(line.split(':')[1] || '0', 10);
    } else if (line.startsWith('FNH:')) {
      // Functions hit
      coveredFunctions += parseInt(line.split(':')[1] || '0', 10);
    } else if (line.startsWith('BRF:')) {
      // Branches found
      totalBranches += parseInt(line.split(':')[1] || '0', 10);
    } else if (line.startsWith('BRH:')) {
      // Branches hit
      coveredBranches += parseInt(line.split(':')[1] || '0', 10);
    }
  }

  if (totalLines === 0 && totalFunctions === 0 && totalBranches === 0) {
    return null;
  }

  return {
    lines: totalLines > 0 ? (coveredLines / totalLines) * 100 : 0,
    functions: totalFunctions > 0 ? (coveredFunctions / totalFunctions) * 100 : 0,
    branches: totalBranches > 0 ? (coveredBranches / totalBranches) * 100 : 0,
    statements: totalLines > 0 ? (coveredLines / totalLines) * 100 : 0, // Use lines as proxy
  };
}

/**
 * Compare coverage metrics
 */
function compareCoverage(
  current: CoverageMetrics,
  baseline: CoverageMetrics
): {
  decreased: boolean;
  differences: Array<{ metric: string; current: number; baseline: number; diff: number }>;
} {
  const differences: Array<{ metric: string; current: number; baseline: number; diff: number }> =
    [];
  let decreased = false;

  const metrics: Array<keyof CoverageMetrics> = ['lines', 'functions', 'branches', 'statements'];
  for (const metric of metrics) {
    const diff = current[metric] - baseline[metric];
    if (diff < -0.01) {
      // Allow 0.01% tolerance for floating point
      decreased = true;
      differences.push({
        metric,
        current: current[metric],
        baseline: baseline[metric],
        diff,
      });
    }
  }

  return { decreased, differences };
}

/**
 * Main function
 */
function main(): void {
  const args = process.argv.slice(2);
  const updateBaseline = args.includes('--update-baseline') || args.includes('-u');

  console.log('ðŸ” Checking coverage decrease...\n');

  // Parse current coverage
  const currentCoverage = parseCoverageReport();
  if (!currentCoverage) {
    console.error('âŒ Could not parse coverage report.\n');
    console.error('ðŸ’¡ Run `pnpm test:coverage` first to generate coverage report.\n');
    process.exit(1);
  }

  console.log('ðŸ“Š Current coverage:');
  console.log(`  Lines:      ${currentCoverage.lines.toFixed(2)}%`);
  console.log(`  Functions:  ${currentCoverage.functions.toFixed(2)}%`);
  console.log(`  Branches:   ${currentCoverage.branches.toFixed(2)}%`);
  console.log(`  Statements: ${currentCoverage.statements.toFixed(2)}%`);
  console.log('');

  // Read baseline
  const baseline = readBaseline();

  if (!baseline) {
    console.log('â„¹ï¸  No baseline found. Creating baseline from current coverage...\n');
    writeBaseline(currentCoverage);
    console.log('âœ… Baseline created.\n');
    process.exit(0);
  }

  console.log('ðŸ“Š Baseline coverage:');
  console.log(`  Lines:      ${baseline.lines.toFixed(2)}%`);
  console.log(`  Functions:  ${baseline.functions.toFixed(2)}%`);
  console.log(`  Branches:   ${baseline.branches.toFixed(2)}%`);
  console.log(`  Statements: ${baseline.statements.toFixed(2)}%`);
  console.log('');

  // Compare
  const comparison = compareCoverage(currentCoverage, baseline);

  if (comparison.decreased) {
    console.error('âŒ Coverage decreased below baseline:\n');
    for (const diff of comparison.differences) {
      console.error(
        `  ${diff.metric}: ${diff.current.toFixed(2)}% (baseline: ${diff.baseline.toFixed(2)}%, diff: ${diff.diff.toFixed(2)}%)`
      );
    }
    console.error('');
    console.error('ðŸ’¡ To fix:');
    console.error('   1. Add tests to increase coverage');
    console.error('   2. Or update baseline with --update-baseline if decrease is acceptable');
    console.error('');
    process.exit(1);
  }

  console.log('âœ… Coverage meets or exceeds baseline!\n');

  // Update baseline if requested
  if (updateBaseline) {
    console.log('ðŸ“ Updating baseline...\n');
    writeBaseline(currentCoverage);
    console.log('âœ… Baseline updated.\n');
  }

  process.exit(0);
}

main();
