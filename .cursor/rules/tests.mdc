---
description: Testing rules for tests/ directory - test organization, structure, coverage, mocking
globs:
  - "tests/**/*.ts"
  - "**/*.test.ts"
  - "**/*.spec.ts"
alwaysApply: false
---

# Testing Rules (DEPRECATED - See testing.mdc)

> **⚠️ This file is deprecated. See `testing.mdc` for comprehensive testing rules including property tests, fuzzing, and crypto backend testing.**

# Testing Rules

## Test Organization

### Directory Structure

- `tests/unit/` - Unit tests for individual functions and classes
- `tests/integration/` - Integration tests for interactions between components
- `tests/__mocks__/` - Reusable mock implementations

### File Naming

- Unit test files must use `.test.ts` or `.spec.ts` suffix
- Co-locate test files with source files when appropriate
- Use descriptive file names that indicate the unit under test

## Test Structure

- Use AAA pattern (Arrange, Act, Assert) in all test cases
- Prefer one assertion per test when possible
- Use descriptive test names
- Group related tests using `describe` blocks
- Use `beforeEach` and `afterEach` hooks for setup and teardown

## Test Coverage

- Aim for 80%+ code coverage
- Focus on business logic coverage
- Test edge cases and error conditions
- Test both success and failure paths
- Don't test implementation details

## Mocking

- Mock external dependencies (APIs, databases, file system)
- Use vitest mocks for functions and modules
- Create reusable mock factories
- Reset mocks between tests
- Verify mock calls when appropriate

## Async Testing

- Use async/await in tests
- Wait for async operations to complete
- Test error handling in async code
- Use proper timeout values
- Clean up async resources

## Test Data

- Use factories for test data creation
- Keep test data minimal and focused
- Use realistic but simplified data
- Avoid hardcoded values when possible
- Clean up test data after tests

## Assertions

- Use descriptive assertion messages
- Test one thing per assertion
- Use appropriate matchers
- Test both positive and negative cases
- Verify error messages when testing errors

## Performance

- Keep tests fast (< 100ms per test)
- Use parallel test execution
- Avoid unnecessary setup/teardown
- Mock slow operations

## Integration Tests

- Test real component interactions
- Use test databases when needed
- Clean up after integration tests
- Test error scenarios
- Verify side effects

## Test Utilities

- Create reusable test utilities
- Use test helpers for common patterns
- Create custom matchers when needed
- Share test fixtures across tests
- Document test utilities

## Documentation

- Document complex test scenarios
- Explain why tests exist
- Document test data requirements
- Include examples in test descriptions
- Keep test code readable
