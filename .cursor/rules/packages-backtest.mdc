---
description: "QuantBot Backtest package rules - Minimum Viable Backtester (MVB) architecture enforcement."
globs:
  - "packages/backtest/**"
  - "packages/cli/src/commands/backtest.ts"
  - "packages/cli/src/handlers/backtest/**"
alwaysApply: true
---

"""
Minimum Viable Backtester (MVB) - Simple, focused architecture that respects core invariants
(coverage + slices + determinism) without unnecessary ceremony.

Golden Path: One command does the full vertical slice from planning to reporting.

Core Principle: If it exceeds 6 files to read end-to-end, 2 abstraction jumps, or 1 config layer,
it's too heavy.
"""

## Architecture - Only 4 Moving Parts

The backtest package must maintain exactly 4 components:

1. **Planner** (`plan.ts`) - Requirements + coverage gate
2. **Slice Loader** (`slice.ts`) - Get candles fast
3. **Backtest Engine** (`engine/`) - Pure simulation logic
4. **Reporter** (`report.ts`) - Summary + trades + optional replay

### Forbidden Patterns

- ❌ Additional orchestration layers beyond these 4 components
- ❌ Intermediate abstraction layers between planner → slice → engine → reporter
- ❌ Multiple config layers (only `.env` → `Config` object allowed)
- ❌ Complex dependency injection frameworks
- ❌ Unnecessary service wrappers

## File Structure Constraints

### Required File Structure

```
packages/backtest/
  src/
    runBacktest.ts      # orchestrator: plan -> coverage -> slice -> engine -> persist
    plan.ts             # requirements + coverage gate
    coverage.ts         # coverage calculation
    slice.ts            # fast candle loading
    engine/             # pure simulation
      index.ts
    report.ts           # summary + trades + replay
    types.ts            # core types
    index.ts            # exports
```

### File Count Limit

**Maximum 6 files to read end-to-end for the golden path.**

This means:
- ✅ Core golden path must be readable in ≤6 files
- ❌ No deep nesting or excessive file splitting
- ❌ No intermediate wrappers that add abstraction without value

### Abstraction Jump Limit

**Maximum 2 abstraction jumps between steps.**

Example valid flow:
1. `runBacktest.ts` → calls `plan.ts` (1 jump)
2. `plan.ts` → calls `coverage.ts` (2 jumps from entry)
3. `slice.ts` → calls engine (2 jumps from entry)

**Forbidden:**
- ❌ More than 2 function calls deep from entry point
- ❌ Wrapper functions that only delegate without adding value
- ❌ Intermediate adapters between core components

## Golden Path Command

### Command Structure

One command does the full vertical slice:

```bash
quantbot backtest run --strategy <id> --filter <id> --interval 1m --from 2024-01-01T00:00:00Z --to 2024-01-31T23:59:59Z
```

### Success Criteria

Command must output:
- ✅ Coverage summary (eligible/excluded)
- ✅ Run summary (P&L, trades, drawdown)
- ✅ Artifacts persisted

### CLI Handler Contract

**Location**: `packages/cli/src/handlers/backtest/run.ts`

**Rules**:
- ✅ Parse command arguments
- ✅ Build backtest spec
- ✅ Call `runBacktest()` from `@quantbot/backtest`
- ✅ Format output (coverage, summary, artifacts)
- ❌ NO orchestration logic (delegate to `runBacktest`)
- ❌ NO direct database/API calls
- ❌ NO multi-step business flows

## Storage Patterns

### Required Storage Strategy

- **Trades + Summary** → DuckDB (via artifacts)
- **Replay frames** → NDJSON files (per token per run)
- **ClickHouse** → Candles only (no simulation events)

### Forbidden Storage Patterns

- ❌ Storing simulation events in ClickHouse
- ❌ Mixing storage formats (use DuckDB for structured, NDJSON for replay)
- ❌ Storing candles in DuckDB (use ClickHouse)

## API Contract

### runBacktest Function

**Signature**:

```typescript
export async function runBacktest(
  spec: BacktestSpec,
  options: BacktestOptions
): Promise<BacktestResult>
```

**Spec Requirements**:
- ✅ `strategyId: string` - Strategy identifier
- ✅ `filterId: string` - Filter identifier
- ✅ `interval: '1m' | '5m' | '15m' | '1h'` - Candle interval
- ✅ `from: DateTime` - Start time (Luxon DateTime)
- ✅ `to: DateTime` - End time (Luxon DateTime)

**Options Requirements**:
- ✅ `overlays: ExitOverlay[]` - Exit strategy overlays
- ✅ `fees: { takerFeeBps: number; slippageBps: number }` - Fee configuration
- ✅ `position: { notionalUsd: number }` - Position sizing
- ✅ `includeReplay: boolean` - Whether to generate replay frames

**Result Requirements**:
- ✅ Coverage summary (eligible/excluded counts)
- ✅ Run summary (P&L, trade count, drawdown)
- ✅ Trades array (serializable)
- ✅ Optional replay frames (NDJSON format)

## Design Principles (Non-Negotiable)

### Principle 1: One Vertical Slice Module

- ✅ All golden path code in one folder (`packages/backtest/src/`)
- ❌ No scattered logic across multiple packages
- ❌ No separate "core" vs "implementation" split

### Principle 2: File Count Limit

- ✅ Maximum 6 files to read end-to-end
- ❌ No file splitting for "organization" that increases cognitive load
- ❌ No intermediate abstraction files

### Principle 3: Abstraction Jump Limit

- ✅ Maximum 2 abstraction jumps between steps
- ❌ No wrapper functions that only delegate
- ❌ No unnecessary indirection

### Principle 4: One Config Layer

- ✅ `.env` → `Config` object (single transformation)
- ❌ No config parsing → validation → normalization → application layers
- ❌ No runtime config reloading

## Component Responsibilities

### Planner (`plan.ts`)

**Responsibilities**:
- ✅ Validate strategy and filter exist
- ✅ Calculate coverage (eligible vs excluded calls)
- ✅ Gate execution if coverage insufficient
- ❌ NO candle loading
- ❌ NO simulation logic
- ❌ NO reporting

### Slice Loader (`slice.ts`)

**Responsibilities**:
- ✅ Load candles fast (ClickHouse first, API fallback)
- ✅ Return candles in correct format for engine
- ✅ Handle missing data gracefully
- ❌ NO coverage calculation
- ❌ NO simulation logic
- ❌ NO persistence

### Backtest Engine (`engine/`)

**Responsibilities**:
- ✅ Pure simulation logic (deterministic)
- ✅ Process candles through strategy
- ✅ Apply exit overlays
- ✅ Calculate P&L, fees, slippage
- ❌ NO I/O operations
- ❌ NO database calls
- ❌ NO API calls
- ❌ NO clock/time dependencies (use provided timestamps)

### Reporter (`report.ts`)

**Responsibilities**:
- ✅ Generate summary statistics
- ✅ Format trades for persistence
- ✅ Generate replay frames (if requested)
- ✅ Persist to DuckDB and NDJSON
- ❌ NO simulation logic
- ❌ NO candle loading

## Testing Requirements

### Unit Tests

**Required for each component**:
- ✅ Planner: Coverage calculation, validation
- ✅ Slice Loader: Candle loading, fallback logic
- ✅ Engine: Deterministic simulation, P&L calculation
- ✅ Reporter: Summary generation, persistence

### Integration Tests

**Required for golden path**:
- ✅ End-to-end backtest execution
- ✅ Coverage → slice → engine → report flow
- ✅ Artifact persistence verification

### Test Independence

**Forbidden in tests**:
- ❌ Importing fee/rounding calculators from production modules
- ❌ Importing constants from simulation for expected values
- ❌ Sharing test helpers that duplicate production logic

**Allowed**:
- ✅ Local helper functions inside test file (only used by tests)
- ✅ Hard-coded numeric expectations
- ✅ Independent calculation of expected values

**Reason**: If production math changes, tests should FAIL unless behavior is truly unchanged.

## Error Handling

### Coverage Gate

- ✅ If coverage < threshold, fail fast with clear message
- ✅ Report eligible vs excluded counts
- ❌ NO silent failures or partial execution

### Missing Data

- ✅ Slice loader returns empty array for missing candles
- ✅ Engine handles empty candle arrays gracefully
- ✅ Reporter includes data quality metrics in summary

### Simulation Errors

- ✅ Collect per-call errors, don't fail entire backtest
- ✅ Include error counts in summary
- ❌ NO silent error swallowing

## Performance Requirements

### Candle Loading

- ✅ Check ClickHouse first (fast path)
- ✅ API fallback only when needed
- ✅ Batch loading where possible
- ❌ NO redundant API calls when ClickHouse has data

### Simulation Speed

- ✅ Engine must be pure and fast (no I/O)
- ✅ Process candles in single pass
- ❌ NO multiple passes over same data
- ❌ NO unnecessary allocations

## Enforcement

### Code Review Checklist

When reviewing backtest code:

- [ ] File count ≤ 6 for golden path
- [ ] Abstraction jumps ≤ 2 between steps
- [ ] Only one config layer (`.env` → `Config`)
- [ ] Components maintain single responsibility
- [ ] No forbidden patterns (see above)
- [ ] Tests use independent calculations
- [ ] Storage patterns follow requirements

### Pre-Commit Checks

- Verify file structure matches requirements
- Check for forbidden imports (I/O in engine, etc.)
- Ensure test independence

### AI Assistant Rules

- **ALWAYS** enforce 6-file limit when suggesting changes
- **ALWAYS** warn if abstraction jumps exceed 2
- **ALWAYS** suggest simplification if config layers multiply
- **NEVER** add intermediate wrappers without justification
- **NEVER** split files for "organization" if it increases file count

## Success Criteria

The golden path is successful if:

- ✅ No more than 6 files to read end-to-end
- ✅ No more than 2 abstraction jumps between steps
- ✅ No more than one config layer
- ✅ All 4 components (planner, slice, engine, reporter) are clearly separated
- ✅ Command outputs coverage, summary, and artifacts
- ✅ Tests use independent calculations

**If it exceeds these limits, it's too heavy and must be simplified.**
