---
description: "QuantBot Workflows package rules (orchestration layer)."
globs:
  - "packages/workflows/**"
  - "packages/cli/src/commands/**"
alwaysApply: False
---

"""
Workflows are the orchestration layer. They coordinate storage + ohlcv + simulation.
CLI/TUI are *thin adapters* that parse inputs, call workflows, format output.

Goals:

- No multi-step business flows live inside CLI command handlers.
- Workflows must be testable in isolation via a mocked WorkflowContext.
- Simulation remains pure compute (no network/db/fs) ‚Äî workflows do I/O.
"""

## Architecture Layers

### Layer Responsibilities

**Workflows = Orchestration (Application Layer)**

- Use cases that glue together storage + acquisition + simulation
- Coordinate I/O operations
- Handle error collection and aggregation
- Return structured, serializable results

**Simulation = Pure Compute**

- No I/O, no clocks, no global config
- Given inputs ‚Üí deterministic outputs
- Testable without I/O chaos contaminating results
- Critical for sniping/latency-sensitive strategies

**CLI/TUI = Adapters**

- Translate human intent ‚Üí spec
- Translate result ‚Üí presentation
- No orchestration logic

**Reason**: This separation is especially correct for sniping/latency-sensitive strategies because it lets you test and iterate strategy logic without I/O chaos contaminating results.

## Required layering

### Allowed dependencies for @quantbot/workflows

- ‚úÖ @quantbot/storage (interfaces only, not implementations)
- ‚úÖ @quantbot/ohlcv (data acquisition, via context)
- ‚úÖ @quantbot/simulation (pure compute)
- ‚úÖ @quantbot/utils (logger, config)
- ‚úÖ zod, luxon (validation/time)

### Dependency injection rule (critical)

**Workflows depend on interfaces, not implementations**

**Required pattern**:

```typescript
// ‚úÖ CORRECT: Use context methods
await ctx.ohlcv.fetchCandles(...);
await ctx.repos.simulationRuns.saveRun(...);
```

**Forbidden**:

```typescript
// ‚ùå WRONG: Direct implementation imports
import { PostgresRunRepo } from '@quantbot/storage/src/postgres/run-repo';
import { ClickHouseClient } from '@quantbot/storage/src/clickhouse/client';

// ‚ùå WRONG: Instantiating implementations
const repo = new PostgresRunRepo(connection);
```

**Reason**: Keeps DI real, prevents "just this once" imports that metastasize. All dependencies must come through `WorkflowContext`.

### Forbidden patterns

- ‚ùå CLI handlers performing multi-step flows (ingest‚Üífetch‚Üísimulate‚Üípersist)
- ‚ùå Workflows importing from @quantbot/cli or @quantbot/tui
- ‚ùå Workflows exposing CLI-format output (tables/console formatting belongs to CLI/TUI)
- ‚ùå Workflows returning ‚Äústrings‚Äù intended for CLI printing (return structured results)

## Workflow function contract

Every workflow must:

1) Validate `spec` (Zod schema preferred)
2) Use `WorkflowContext` (DI) for:
   - repositories (storage)
   - services (ohlcv)
   - logger
   - now()/clock (determinism in tests)
3) Return a structured result:
   - summary stats
   - counts
   - per-item errors (do not throw for per-call failures unless requested)
   - metadata (timestamps, run id, strategy name)

### Error policy (required in spec)

Every workflow spec must define error handling behavior explicitly:

```typescript
type WorkflowSpec = {
  // ... other fields ...
  failFast?: boolean; // OR
  errorMode?: 'collect' | 'failFast';
}
```

**Reason**: Prevents different workflows from "feeling" different and callers developing superstition.

- `failFast: true` / `errorMode: 'failFast'`: Throw on first error, stop processing
- `failFast: false` / `errorMode: 'collect'`: Collect errors, continue processing, return errors in result

### Result serialization (required)

**Result must be JSON-serializable (JSON-safe)**

**Forbidden in results**:

- ‚ùå Date objects (use ISO strings: `DateTime.toISO()`)
- ‚ùå Class instances (use plain objects)
- ‚ùå Logger objects
- ‚ùå Functions
- ‚ùå Circular references
- ‚ùå Non-serializable types (Map, Set, etc. - convert to arrays/objects)

**Reason**: Makes it trivial to persist run outputs, diff them in tests, ship them to a UI later, or replay runs.

**Validation**: Use Zod schema that enforces JSON-serializable types.

### Signature pattern (required)

**Always accept ctx (no optional inside function body)**

Prefer default parameter pattern:

```typescript
export async function runX(
  spec: XSpec,
  ctx: WorkflowContext = createDefaultWorkflowContext()
): Promise<XResult>
```

**Reason**: Forces defaulting behavior to be explicit and consistent, keeps tests clean.

**Forbidden**:

- ‚ùå Optional ctx with conditional inside function: `ctx = ctx ?? createDefaultWorkflowContext()`
- ‚ùå Creating "hidden singletons" inside the workflow
- ‚ùå Accessing global state or environment variables directly

## CLI command handler contract (thin adapter)

CLI commands must:

- parse args
- build spec
- call workflow
- format output

CLI commands must NOT:

- open DB connections
- call repositories directly for multi-step flows
- implement orchestration logic (no loops over calls + fetch + simulate + persist)

## Enforcement

### ESLint boundaries

**Forbidden imports, forbidden deps**

Configure ESLint rules to enforce:

- ‚ùå Workflows cannot import from `@quantbot/cli` or `@quantbot/tui`
- ‚ùå Workflows cannot import implementation classes (only interfaces/types)
- ‚ùå CLI handlers cannot import workflow internals (only public API)

**Example ESLint config**:

```json
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        "paths": [
          {
            "name": "@quantbot/storage/src/postgres",
            "message": "Use WorkflowContext repos, not direct Postgres imports"
          },
          {
            "name": "@quantbot/cli",
            "message": "Workflows cannot depend on CLI"
          }
        ]
      }
    ]
  }
}
```

### Code review checklist

**"No orchestration in CLI" rule**

Every PR must verify:

- [ ] CLI handlers are thin adapters (parse ‚Üí call workflow ‚Üí format)
- [ ] No multi-step business logic in CLI handlers
- [ ] Workflows use WorkflowContext for all dependencies
- [ ] Workflow results are JSON-serializable
- [ ] Error policy is explicit in workflow spec
- [ ] Tests use independent math/constants (not prod helpers)

### Pre-commit hooks

**Verify workflow contract compliance**

- Check workflow signatures use default parameter pattern
- Verify results are JSON-serializable (Zod schema validation)
- Ensure no forbidden imports in workflows
- Verify CLI handlers don't contain orchestration logic

## Testing requirements for workflows

Workflows must have unit tests that:

- mock WorkflowContext fully (repos + ohlcv + clock)
- assert the workflow steps (calls made with correct args)
- assert structured result shape

### Test independence (critical)

**Tests must NOT share**:

- fee helpers
- rounding helpers
- constants
from production simulation modules.

**If a test needs fee math**:

- Hard-code expected numeric values, OR
- Compute independently inside the test file

**Reason**: Prevents "tests pass because they repeat the same mistake as prod."

### Golden tests

**Golden tests should load fixtures, not call prod math**

```typescript
// ‚úÖ CORRECT: Load fixture data
const fixture = await loadFixture('simulation-result-001.json');
expect(result).toEqual(fixture);

// ‚ùå WRONG: Call production math in test
const expected = calculateFee(amount); // Uses prod code
```

**Reason**: Ensures tests validate actual behavior, not just that prod code runs.

### Property tests

**Property tests can exist, but must use independent generators/logic**

```typescript
// ‚úÖ CORRECT: Independent generator
function generateTestInput() {
  return { amount: randomFloat(0, 1000), feeRate: 0.01 };
}

// ‚ùå WRONG: Reuse prod constants
import { DEFAULT_FEE_RATE } from '@quantbot/simulation';
```

**Reason**: Property tests validate invariants, not implementation details.

### Test harness

**Unit test harness for WorkflowContext (easy mocking)**

Create reusable mock context factory:

```typescript
export function createMockWorkflowContext(overrides?: Partial<WorkflowContext>): WorkflowContext {
  return {
    clock: { now: () => DateTime.now() },
    ids: { generate: () => 'test-id' },
    logger: { info: vi.fn(), error: vi.fn() },
    repos: { /* mock repos */ },
    ohlcv: { /* mock ohlcv */ },
    simulation: { /* mock simulation */ },
    ...overrides,
  };
}
```

**Reason**: Makes tests easy to write and maintain, ensures consistent mocking.

## Enforcement Trio (Practical)

To keep the architecture enforced (not just declared), use these three mechanisms:

### 1. ESLint Architectural Boundaries

> **Requirement:** Enforce clean architectural boundaries between workflows (application/orchestration), adapters/CLI, and infrastructure implementations using ESLint and dependency rules.

#### ESLint Dependency Boundaries (2026)

Configure or extend your ESLint setup with these rulesets:

- `@quantbot/workflows`:
  - üö´ **MUST NOT** import from any CLI or TUI packages  
    ‚Üí `@quantbot/cli`, `@quantbot/tui` are forbidden import sources.
  - üö´ **MUST NOT** import from any infrastructure implementation classes or files  
    ‚Üí Only depend on *interfaces* (ports), never concrete types (e.g., `PostgresRunRepo`, `ClickHouseClient`, etc).
  - üö´ **MUST NOT** depend on test helpers or CLI-specific internals.

- CLI/Adapter layers:
  - üö´ **MUST NOT** import private/internal workflow utilities  
    ‚Üí Only import stable/public workflow entry points.

- All layers:
  - üü© **SHOULD** enforce import restriction patterns in ESLint configuration, e.g.:
    ```json
    {
      "no-restricted-imports": [
        "error",
        {
          "patterns": [
            {
              "group": [
                "**/src/implementation/**",
                "@quantbot/cli",
                "@quantbot/tui",
                "**/src/postgres/**",
                "**/src/clickhouse/**"
              ],
              "message": "Do not import adapters, CLI, or infrastructure implementation types in workflows."
            }
          ]
        }
      ]
    }
    ```
  - üü© **SHOULD** use `eslint-plugin-boundaries` or equivalent for package-level protections.

#### Recap: Forbidden Imports

| Layer            | Forbidden Import                     | Guidance                                                         |
|------------------|-------------------------------------|------------------------------------------------------------------|
| workflows        | `@quantbot/cli`, `@quantbot/tui`    | Use only interfaces, not CLI/adapters                            |
| workflows        | infra implementations, e.g.         | Use context-provided interfaces; never concrete classes          |
|                  | `PostgresRunRepo`, `ClickHouseClient` |                                                                  |
| cli-handlers     | workflow internals (private/utils)  | Import only public API of workflows                              |

**Why:**  
These rules prevent architectural drift, ensure workflows remain adapter- and infrastructure-agnostic, and keep CLI/adapters free from orchestration logic.

**Reference:**  
[eslint-plugin-boundaries](https://github.com/javierbrea/eslint-plugin-boundaries)  
[Node.js import restrictions (ESLint docs)](https://eslint.org/docs/latest/rules/no-restricted-imports)


### 2. Unit Test Harness for WorkflowContext

**Easy mocking for all workflow tests**

Create reusable mock context factory (see "Test harness" section above). This makes correct patterns easy and incorrect patterns hard.

### 3. "No Orchestration in CLI" Rule

**Lint + code review checklist**

- ESLint rule to detect multi-step flows in CLI handlers
- Code review checklist (see "Code review checklist" section above)
- Pre-commit hooks to verify workflow contract compliance

**Why this trio works**: ESLint catches violations at write-time, test harness makes correct patterns easy, code review ensures human oversight. Together they prevent architectural drift.
