---
description: QuantBot Data Access and Loader Best Practices
globs:
  - "packages/data/**/*.ts"
alwaysApply: false
---

# QuantBot Data Access and Loader Best Practices

## Data Access Layer Architecture

- Adopt the data loader pattern for all structured data retrieval
- Support pluggable sources: CSV, ClickHouse, APIs, etc.
- Centralize input validation and sanitization
- Maintain strict separation of data access from business logic
- Implement caching (in-memory/Redis) where high performance is needed
- Favor dependency injection for testable loaders
- Handle edge cases and errors consistently
- Expose batch loading interface where relevant

## Loader Contracts and Implementation Rules

### Interface

- All loaders implement a common DataLoader interface
- Interface must define: `load`, `validate`, `clearCache` methods
- Batch loading must be supported where useful
- Return typed, structured results (discriminated unions or `Result<T, E>`)

### Implementation

- Use factory pattern for loader instantiation by source type
- Ensure each loader encapsulates its data source (no leakage)
- Constructor injection for all dependencies is required

## Source-Specific Best Practices

### CSV

- Schema and column validation required upon load
- Handle malformed, missing, or empty files gracefully
- Default to UTF-8 decoding; validate file encoding
- Skip and log incomplete rows

### ClickHouse

- Use parameterized queries for safety
- Validate results against expected schema (shape, types)
- Retry transient errors, validate connection health
- Cache costly queries with sensible TTL
- Log and monitor all query timings

### External API

- Isolate remote integration in `ApiLoader` classes
- Use exponential backoff/retry on remote errors
- Validate and sanitize all inbound responses
- Log API calls and errors with context
- Cache remote responses as needed, respect rate limits and ETags

### Caller

- Validate incoming caller data structure
- Handle missing or incomplete caller data gracefully
- Cache and update caller data as appropriate

## Data Validation

### Zod

- All input data must be validated with Zod schemas
- Check shapes, types, required fields, data ranges
- Surface comprehensible error messages on validation failure
- Fail fast on critical validation errors
- Document Zod schemas alongside loader code

## Transformation

- Consistently transform and normalize raw data
- Handle and document missing or optional fields
- Preserve original data integrity during transformation

## Caching

### Strategy

- Cache expensive or repeated loads
- Support configurable TTLs based on volatility
- Invalidate cache on source update or data mutation
- Expose cache metrics and handle backend cache errors robustly

### Management

- Clean up expired cache entries regularly
- Provide cache diagnostics and statistics
- Implement cache warming when beneficial

## Error Handling

- Wrap low-level errors in `DataLoaderError` or custom error types
- Never leak sensitive or internal details (paths, stacktraces) to the user
- Provide context-rich, user-friendly messages for all errors
- Logging must contain useful context for debugging
- Never crash loader on recoverable/malformed data; log and skip
- Notify and alert on critical loader failures
- Retry transient failures when appropriate; fail gracefully on persistent failures
- Implement fallback strategies where available

## Testing

### Unit

- Unit test every loader, including edge and error cases
- Mock external dependencies: filesystems, DBs, APIs
- Test invalid, missing, and badly-encoded files
- Test cache invalidation, error propagation

### Integration

- Integration test against real sources in CI (safe fixtures only)
- Exercise code with real-world data quirks and edge cases
- Tests must be deterministic for known data
- Verify caching, error handling, and fallback logic in integration tests

## Performance

### Loading

- Stream large files where feasible; chunk large datasets
- Batch data loads and queries appropriately
- Optimize memory usage for big loads via chunking
- Profile loaders and eliminate bottlenecks proactively
- Use efficient structures for lookups (`Map`, `Set`)

### Queries

- Optimize DB queries, use appropriate indexes
- Minimize data transfer size and round-trips
- Cache repeated query results
- Track query timing for database sources

## Documentation

### Loaders

- Document each loader, including interface contract and source expectations
- Document all Zod schema shapes, CSV/database column formats
- Include illustrative usage examples for every loader
- Document error and edge cases, and their handling
- Keep comments and documentation current as code changes

### Code

- Explain core loader logic with concise comments
- Document significant data transformations and caching strategies
- Example snippets recommended for non-obvious patterns
